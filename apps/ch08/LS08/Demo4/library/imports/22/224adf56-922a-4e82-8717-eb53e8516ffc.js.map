{"version":3,"sources":["../../../../../../../../../../../../assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger/actors/utils/assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger/actors/utils/TabSources.js"],"names":["TabSources","threadActor","allowSourceFn","EventEmitter","decorate","_thread","_useSourceMaps","_autoBlackBox","_anonSourceMapId","allowSource","isHiddenSource","source","blackBoxedSources","Set","prettyPrintedSources","Map","_sourceMaps","_sourceMapCache","Object","create","_sourceActors","_sourceMappedSourceActors","MINIFIED_SOURCE_REGEXP","prototype","reconfigure","options","useSourceMaps","autoBlackBox","reset","opts","sourceMaps","originalUrl","generatedSource","isInlineSource","contentType","dbg_assert","url","has","get","actor","SourceActor","thread","sourceActorStore","id","getReusableActorId","actorID","threadLifetimePool","addActor","setReusableActorId","_isMinifiedURL","blackBox","set","_emitNewSource","emit","fetchSourceMap","then","map","getSourceActor","Error","getSourceActorByURL","aURL","Services","io","newURI","QueryInterface","Ci","nsIURL","test","fileName","e","createNonSourceMappedActor","aSource","isEvalSource","spec","element","unsafeDereference","tagName","hasAttribute","urlInfo","fileExtension","ex","indexOf","_createSourceMappedActors","sourceMapURL","resolve","sources","s","filter","isNotNull","createSourceActors","actors","_normalize","result","_fetchSourceMap","getSourceMap","setSourceMap","aMap","aAbsSourceMapURL","aSourceURL","fetching","fetch","loadFromCache","content","SourceMapConsumer","_setSourceMapRoot","DevToolsUtils","reportingDisabled","reportException","error","aSourceMap","aScriptURL","hasContentsOfAllSources","base","_dirname","sourceRoot","aPath","clearSourceMapCache","aSourceMapURL","hard","oldSm","entries","sm","delete","setSourceMapHard","aUrl","getFrameLocation","aFrame","script","GeneratedLocation","getOffsetLine","offset","getOffsetColumn","getOriginalLocation","generatedLocation","generatedSourceActor","generatedLine","generatedColumn","_originalUrl","originalPositionFor","line","column","Infinity","originalLine","originalColumn","originalName","name","OriginalLocation","fromGeneratedLocation","getAllGeneratedLocations","originalLocation","originalSourceActor","computeColumnSpans","allGeneratedPositionsFor","lastColumn","fromOriginalLocation","getGeneratedLocation","generatedPositionFor","bias","LEAST_UPPER_BOUND","isBlackBoxed","add","unblackBox","isPrettyPrinted","prettyPrint","aIndent","prettyPrintIndent","disablePrettyPrint","aURLs","length","pop","iter","keys","k","values","push","text","aThing","exports"],"mappings":"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","file":"TabSources.js","sourceRoot":"../../../../../../../../../../../../assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger/actors/utils","sourcesContent":["/****************************************************************************\n Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.\n \n http://www.cocos2d-x.org\n \n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n \n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n \n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n ****************************************************************************/\n\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\"use strict\";\n\n// const { Ci, Cu } = require(\"chrome\");\n// const Services = require(\"Services\");\n// const DevToolsUtils = require(\"devtools/toolkit/DevToolsUtils\");\n// const { dbg_assert, fetch } = DevToolsUtils;\n// const EventEmitter = require(\"devtools/toolkit/event-emitter\");\n// const { OriginalLocation, GeneratedLocation, getOffsetColumn } = require(\"devtools/server/actors/common\");\n// const { resolve } = require(\"promise\");\n\n// loader.lazyRequireGetter(this, \"SourceActor\", \"devtools/server/actors/script\", true);\n// loader.lazyRequireGetter(this, \"isEvalSource\", \"devtools/server/actors/script\", true);\n// loader.lazyRequireGetter(this, \"SourceMapConsumer\", \"source-map\", true);\n// loader.lazyRequireGetter(this, \"SourceMapGenerator\", \"source-map\", true);\n\n/**\n * Manages the sources for a thread. Handles source maps, locations in the\n * sources, etc for ThreadActors.\n */\nfunction TabSources(threadActor, allowSourceFn=() => true) {\n  EventEmitter.decorate(this);\n\n  this._thread = threadActor;\n  this._useSourceMaps = true;\n  this._autoBlackBox = true;\n  this._anonSourceMapId = 1;\n  this.allowSource = source => {\n    return !isHiddenSource(source) && allowSourceFn(source);\n  }\n\n  this.blackBoxedSources = new Set();\n  this.prettyPrintedSources = new Map();\n\n  // generated Debugger.Source -> promise of SourceMapConsumer\n  this._sourceMaps = new Map();\n  // sourceMapURL -> promise of SourceMapConsumer\n  this._sourceMapCache = Object.create(null);\n  // Debugger.Source -> SourceActor\n  this._sourceActors = new Map();\n  // url -> SourceActor\n  this._sourceMappedSourceActors = Object.create(null);\n}\n\n/**\n * Matches strings of the form \"foo.min.js\" or \"foo-min.js\", etc. If the regular\n * expression matches, we can be fairly sure that the source is minified, and\n * treat it as such.\n */\nconst MINIFIED_SOURCE_REGEXP = /\\bmin\\.js$/;\n\nTabSources.prototype = {\n  /**\n   * Update preferences and clear out existing sources\n   */\n  reconfigure: function(options) {\n    if ('useSourceMaps' in options) {\n      this._useSourceMaps = options.useSourceMaps;\n    }\n\n    if ('autoBlackBox' in options) {\n      this._autoBlackBox = options.autoBlackBox;\n    }\n\n    this.reset();\n  },\n\n  /**\n   * Clear existing sources so they are recreated on the next access.\n   *\n   * @param Object opts\n   *        Specify { sourceMaps: true } if you also want to clear\n   *        the source map cache (usually done on reload).\n   */\n  reset: function(opts={}) {\n    this._sourceActors = new Map();\n    this._sourceMaps = new Map();\n    this._sourceMappedSourceActors = Object.create(null);\n\n    if (opts.sourceMaps) {\n      this._sourceMapCache = Object.create(null);\n    }\n  },\n\n  /**\n   * Return the source actor representing the `source` (or\n   * `originalUrl`), creating one if none exists already. May return\n   * null if the source is disallowed.\n   *\n   * @param Debugger.Source source\n   *        The source to make an actor for\n   * @param String originalUrl\n   *        The original source URL of a sourcemapped source\n   * @param optional Debguger.Source generatedSource\n   *        The generated source that introduced this source via source map,\n   *        if any.\n   * @param optional String contentType\n   *        The content type of the source, if immediately available.\n   * @returns a SourceActor representing the source or null.\n   */\n  source: function  ({ source, originalUrl, generatedSource,\n              isInlineSource, contentType }) {\n    dbg_assert(source || (originalUrl && generatedSource),\n               \"TabSources.prototype.source needs an originalUrl or a source\");\n\n    if (source) {\n      // If a source is passed, we are creating an actor for a real\n      // source, which may or may not be sourcemapped.\n\n      if (!this.allowSource(source)) {\n        return null;\n      }\n\n      // It's a hack, but inline HTML scripts each have real sources,\n      // but we want to represent all of them as one source as the\n      // HTML page. The actor representing this fake HTML source is\n      // stored in this array, which always has a URL, so check it\n      // first.\n      if (source.url in this._sourceMappedSourceActors) {\n        return this._sourceMappedSourceActors[source.url];\n      }\n\n      if (isInlineSource) {\n        // If it's an inline source, the fake HTML source hasn't been\n        // created yet (would have returned above), so flip this source\n        // into a sourcemapped state by giving it an `originalUrl` which\n        // is the HTML url.\n        originalUrl = source.url;\n        source = null;\n      }\n      else if (this._sourceActors.has(source)) {\n        return this._sourceActors.get(source);\n      }\n    }\n    else if (originalUrl) {\n      // Not all \"original\" scripts are distinctly separate from the\n      // generated script. Pretty-printed sources have a sourcemap for\n      // themselves, so we need to make sure there a real source\n      // doesn't already exist with this URL.\n      for (let [source, actor] of this._sourceActors) {\n        if (source.url === originalUrl) {\n          return actor;\n        }\n      }\n\n      if (originalUrl in this._sourceMappedSourceActors) {\n        return this._sourceMappedSourceActors[originalUrl];\n      }\n    }\n\n    let actor = new SourceActor({\n      thread: this._thread,\n      source: source,\n      originalUrl: originalUrl,\n      generatedSource: generatedSource,\n      isInlineSource: isInlineSource,\n      contentType: contentType\n    });\n\n    let sourceActorStore = this._thread.sourceActorStore;\n    var id = sourceActorStore.getReusableActorId(source, originalUrl);\n    if (id) {\n      actor.actorID = id;\n    }\n\n    this._thread.threadLifetimePool.addActor(actor);\n    sourceActorStore.setReusableActorId(source, originalUrl, actor.actorID);\n\n    if (this._autoBlackBox && this._isMinifiedURL(actor.url)) {\n      this.blackBox(actor.url);\n    }\n\n    if (source) {\n      this._sourceActors.set(source, actor);\n    }\n    else {\n      this._sourceMappedSourceActors[originalUrl] = actor;\n    }\n\n    this._emitNewSource(actor);\n    return actor;\n  },\n\n  _emitNewSource: function(actor) {\n    if (!actor.source) {\n      // Always notify if we don't have a source because that means\n      // it's something that has been sourcemapped, or it represents\n      // the HTML file that contains inline sources.\n      this.emit('newSource', actor);\n    }\n    else {\n      // If sourcemapping is enabled and a source has sourcemaps, we\n      // create `SourceActor` instances for both the original and\n      // generated sources. The source actors for the generated\n      // sources are only for internal use, however; breakpoints are\n      // managed by these internal actors. We only want to notify the\n      // user of the original sources though, so if the actor has a\n      // `Debugger.Source` instance and a valid source map (meaning\n      // it's a generated source), don't send the notification.\n      this.fetchSourceMap(actor.source).then(map => {\n        if (!map) {\n          this.emit('newSource', actor);\n        }\n      });\n    }\n  },\n\n  getSourceActor: function(source) {\n    if (source.url in this._sourceMappedSourceActors) {\n      return this._sourceMappedSourceActors[source.url];\n    }\n\n    if (this._sourceActors.has(source)) {\n      return this._sourceActors.get(source);\n    }\n\n    throw new Error('getSource: could not find source actor for ' +\n                    (source.url || 'source'));\n  },\n\n  getSourceActorByURL: function(url) {\n    if (url) {\n      for (let [source, actor] of this._sourceActors) {\n        if (source.url === url) {\n          return actor;\n        }\n      }\n\n      if (url in this._sourceMappedSourceActors) {\n        return this._sourceMappedSourceActors[url];\n      }\n    }\n\n    throw new Error('getSourceByURL: could not find source for ' + url);\n  },\n\n  /**\n   * Returns true if the URL likely points to a minified resource, false\n   * otherwise.\n   *\n   * @param String aURL\n   *        The URL to test.\n   * @returns Boolean\n   */\n  _isMinifiedURL: function (aURL) {\n    try {\n      let url = Services.io.newURI(aURL, null, null)\n                           .QueryInterface(Ci.nsIURL);\n      return MINIFIED_SOURCE_REGEXP.test(url.fileName);\n    } catch (e) {\n      // Not a valid URL so don't try to parse out the filename, just test the\n      // whole thing with the minified source regexp.\n      return MINIFIED_SOURCE_REGEXP.test(aURL);\n    }\n  },\n\n  /**\n   * Create a source actor representing this source. This ignores\n   * source mapping and always returns an actor representing this real\n   * source. Use `createSourceActors` if you want to respect source maps.\n   *\n   * @param Debugger.Source aSource\n   *        The source instance to create an actor for.\n   * @returns SourceActor\n   */\n  createNonSourceMappedActor: function (aSource) {\n    // Don't use getSourceURL because we don't want to consider the\n    // displayURL property if it's an eval source. We only want to\n    // consider real URLs, otherwise if there is a URL but it's\n    // invalid the code below will not set the content type, and we\n    // will later try to fetch the contents of the URL to figure out\n    // the content type, but it's a made up URL for eval sources.\n    let url = isEvalSource(aSource) ? null : aSource.url;\n    let spec = { source: aSource };\n\n    // XXX bug 915433: We can't rely on Debugger.Source.prototype.text\n    // if the source is an HTML-embedded <script> tag. Since we don't\n    // have an API implemented to detect whether this is the case, we\n    // need to be conservative and only treat valid js files as real\n    // sources. Otherwise, use the `originalUrl` property to treat it\n    // as an HTML source that manages multiple inline sources.\n\n    // Assume the source is inline if the element that introduced it is not a\n    // script element, or does not have a src attribute.\n    let element = aSource.element ? aSource.element.unsafeDereference() : null;\n    if (element && (element.tagName !== \"SCRIPT\" || !element.hasAttribute(\"src\"))) {\n      spec.isInlineSource = true;\n    } else {\n      if (url) {\n        try {\n          let urlInfo = Services.io.newURI(url, null, null).QueryInterface(Ci.nsIURL);\n          if (urlInfo.fileExtension === \"xml\") {\n            // XUL inline scripts may not correctly have the\n            // `source.element` property, so do a blunt check here if\n            // it's an xml page.\n            spec.isInlineSource = true;\n          }\n          else if (urlInfo.fileExtension === \"js\") {\n            spec.contentType = \"text/javascript\";\n          }\n        } catch(ex) {\n          // There are a few special URLs that we know are JavaScript:\n          // inline `javascript:` and code coming from the console\n          if (url.indexOf(\"javascript:\") === 0 || url === 'debugger eval code') {\n            spec.contentType = \"text/javascript\";\n          }\n        }\n      }\n      else {\n        // Assume the content is javascript if there's no URL\n        spec.contentType = \"text/javascript\";\n      }\n    }\n    return this.source(spec);\n  },\n\n  /**\n   * This is an internal function that returns a promise of an array\n   * of source actors representing all the source mapped sources of\n   * `aSource`, or `null` if the source is not sourcemapped or\n   * sourcemapping is disabled. Users should call `createSourceActors`\n   * instead of this.\n   *\n   * @param Debugger.Source aSource\n   *        The source instance to create actors for.\n   * @return Promise of an array of source actors\n   */\n  _createSourceMappedActors: function (aSource) {\n    if (!this._useSourceMaps || !aSource.sourceMapURL) {\n      return resolve(null);\n    }\n\n    return this.fetchSourceMap(aSource)\n      .then(map => {\n        if (map) {\n          return map.sources.map(s => {\n            return this.source({ originalUrl: s, generatedSource: aSource });\n          }).filter(isNotNull);\n        }\n        return null;\n      });\n  },\n\n  /**\n   * Creates the source actors representing the appropriate sources\n   * of `aSource`. If sourcemapped, returns actors for all of the original\n   * sources, otherwise returns a 1-element array with the actor for\n   * `aSource`.\n   *\n   * @param Debugger.Source aSource\n   *        The source instance to create actors for.\n   * @param Promise of an array of source actors\n   */\n  createSourceActors: function(aSource) {\n    return this._createSourceMappedActors(aSource).then(actors => {\n      let actor = this.createNonSourceMappedActor(aSource);\n      return (actors || [actor]).filter(isNotNull);\n    });\n  },\n\n  /**\n   * Return a promise of a SourceMapConsumer for the source map for\n   * `aSource`; if we already have such a promise extant, return that.\n   * This will fetch the source map if we don't have a cached object\n   * and source maps are enabled (see `_fetchSourceMap`).\n   *\n   * @param Debugger.Source aSource\n   *        The source instance to get sourcemaps for.\n   * @return Promise of a SourceMapConsumer\n   */\n  fetchSourceMap: function (aSource) {\n    if (this._sourceMaps.has(aSource)) {\n      return this._sourceMaps.get(aSource);\n    }\n    else if (!aSource || !aSource.sourceMapURL) {\n      return resolve(null);\n    }\n\n    let sourceMapURL = aSource.sourceMapURL;\n    if (aSource.url) {\n      sourceMapURL = this._normalize(sourceMapURL, aSource.url);\n    }\n    let result = this._fetchSourceMap(sourceMapURL, aSource.url);\n\n    // The promises in `_sourceMaps` must be the exact same instances\n    // as returned by `_fetchSourceMap` for `clearSourceMapCache` to work.\n    this._sourceMaps.set(aSource, result);\n    return result;\n  },\n\n  /**\n   * Return a promise of a SourceMapConsumer for the source map for\n   * `aSource`. The resolved result may be null if the source does not\n   * have a source map or source maps are disabled.\n   */\n  getSourceMap: function(aSource) {\n    return resolve(this._sourceMaps.get(aSource));\n  },\n\n  /**\n   * Set a SourceMapConsumer for the source map for\n   * |aSource|.\n   */\n  setSourceMap: function(aSource, aMap) {\n    this._sourceMaps.set(aSource, resolve(aMap));\n  },\n\n  /**\n   * Return a promise of a SourceMapConsumer for the source map located at\n   * |aAbsSourceMapURL|, which must be absolute. If there is already such a\n   * promise extant, return it. This will not fetch if source maps are\n   * disabled.\n   *\n   * @param string aAbsSourceMapURL\n   *        The source map URL, in absolute form, not relative.\n   * @param string aScriptURL\n   *        When the source map URL is a data URI, there is no sourceRoot on the\n   *        source map, and the source map's sources are relative, we resolve\n   *        them from aScriptURL.\n   */\n  _fetchSourceMap: function (aAbsSourceMapURL, aSourceURL) {\n    if (!this._useSourceMaps) {\n      return resolve(null);\n    }\n    else if (this._sourceMapCache[aAbsSourceMapURL]) {\n      return this._sourceMapCache[aAbsSourceMapURL];\n    }\n\n    let fetching = fetch(aAbsSourceMapURL, { loadFromCache: false })\n      .then(({ content }) => {\n        let map = new SourceMapConsumer(content);\n        this._setSourceMapRoot(map, aAbsSourceMapURL, aSourceURL);\n        return map;\n      })\n      .then(null, error => {\n        if (!DevToolsUtils.reportingDisabled) {\n          DevToolsUtils.reportException(\"TabSources.prototype._fetchSourceMap\", error);\n        }\n        return null;\n      });\n    this._sourceMapCache[aAbsSourceMapURL] = fetching;\n    return fetching;\n  },\n\n  /**\n   * Sets the source map's sourceRoot to be relative to the source map url.\n   */\n  _setSourceMapRoot: function (aSourceMap, aAbsSourceMapURL, aScriptURL) {\n    // No need to do this fiddling if we won't be fetching any sources over the\n    // wire.\n    if (aSourceMap.hasContentsOfAllSources()) {\n      return;\n    }\n\n    const base = this._dirname(\n      aAbsSourceMapURL.indexOf(\"data:\") === 0\n        ? aScriptURL\n        : aAbsSourceMapURL);\n    aSourceMap.sourceRoot = aSourceMap.sourceRoot\n      ? this._normalize(aSourceMap.sourceRoot, base)\n      : base;\n  },\n\n  _dirname: function (aPath) {\n    return Services.io.newURI(\n      \".\", null, Services.io.newURI(aPath, null, null)).spec;\n  },\n\n  /**\n   * Clears the source map cache. Source maps are cached by URL so\n   * they can be reused across separate Debugger instances (once in\n   * this cache, they will never be reparsed again). They are\n   * also cached by Debugger.Source objects for usefulness. By default\n   * this just removes the Debugger.Source cache, but you can remove\n   * the lower-level URL cache with the `hard` option.\n   *\n   * @param aSourceMapURL string\n   *        The source map URL to uncache\n   * @param opts object\n   *        An object with the following properties:\n   *        - hard: Also remove the lower-level URL cache, which will\n   *          make us completely forget about the source map.\n   */\n  clearSourceMapCache: function(aSourceMapURL, opts = { hard: false }) {\n    let oldSm = this._sourceMapCache[aSourceMapURL];\n\n    if (opts.hard) {\n      delete this._sourceMapCache[aSourceMapURL];\n    }\n\n    if (oldSm) {\n      // Clear out the current cache so all sources will get the new one\n      for (let [source, sm] of this._sourceMaps.entries()) {\n        if (sm === oldSm) {\n          this._sourceMaps.delete(source);\n        }\n      }\n    }\n  },\n\n  /*\n   * Forcefully change the source map of a source, changing the\n   * sourceMapURL and installing the source map in the cache. This is\n   * necessary to expose changes across Debugger instances\n   * (pretty-printing is the use case). Generate a random url if one\n   * isn't specified, allowing you to set \"anonymous\" source maps.\n   *\n   * @param aSource Debugger.Source\n   *        The source to change the sourceMapURL property\n   * @param aUrl string\n   *        The source map URL (optional)\n   * @param aMap SourceMapConsumer\n   *        The source map instance\n   */\n  setSourceMapHard: function(aSource, aUrl, aMap) {\n    let url = aUrl;\n    if (!url) {\n      // This is a littly hacky, but we want to forcefully set a\n      // sourcemap regardless of sourcemap settings. We want to\n      // literally change the sourceMapURL so that all debuggers will\n      // get this and pretty-printing will Just Work (Debugger.Source\n      // instances are per-debugger, so we can't key off that). To\n      // avoid tons of work serializing the sourcemap into a data url,\n      // just make a fake URL and stick the sourcemap there.\n      url = \"internal://sourcemap\" + (this._anonSourceMapId++) + '/';\n    }\n    aSource.sourceMapURL = url;\n\n    // Forcefully set the sourcemap cache. This will be used even if\n    // sourcemaps are disabled.\n    this._sourceMapCache[url] = resolve(aMap);\n  },\n\n  /**\n   * Return the non-source-mapped location of the given Debugger.Frame. If the\n   * frame does not have a script, the location's properties are all null.\n   *\n   * @param Debugger.Frame aFrame\n   *        The frame whose location we are getting.\n   * @returns Object\n   *          Returns an object of the form { source, line, column }\n   */\n  getFrameLocation: function (aFrame) {\n    if (!aFrame || !aFrame.script) {\n      return new GeneratedLocation();\n    }\n\n    return new GeneratedLocation(\n      this.createNonSourceMappedActor(aFrame.script.source),\n      aFrame.script.getOffsetLine(aFrame.offset),\n      getOffsetColumn(aFrame.offset, aFrame.script)\n    );\n  },\n\n  /**\n   * Returns a promise of the location in the original source if the source is\n   * source mapped, otherwise a promise of the same location. This can\n   * be called with a source from *any* Debugger instance and we make\n   * sure to that it works properly, reusing source maps if already\n   * fetched. Use this from any actor that needs sourcemapping.\n   */\n  getOriginalLocation: function (generatedLocation) {\n    let {\n      generatedSourceActor,\n      generatedLine,\n      generatedColumn\n    } = generatedLocation;\n    let source = generatedSourceActor.source;\n    let url = source ? source.url : generatedSourceActor._originalUrl;\n\n    // In certain scenarios the source map may have not been fetched\n    // yet (or at least tied to this Debugger.Source instance), so use\n    // `fetchSourceMap` instead of `getSourceMap`. This allows this\n    // function to be called from anywere (across debuggers) and it\n    // should just automatically work.\n    return this.fetchSourceMap(source).then(map => {\n      if (map) {\n        let {\n          source: originalUrl,\n          line: originalLine,\n          column: originalColumn,\n          name: originalName\n        } = map.originalPositionFor({\n          line: generatedLine,\n          column: generatedColumn == null ? Infinity : generatedColumn\n        });\n\n        // Since the `Debugger.Source` instance may come from a\n        // different `Debugger` instance (any actor can call this\n        // method), we can't rely on any of the source discovery\n        // setup (`_discoverSources`, etc) to have been run yet. So\n        // we have to assume that the actor may not already exist,\n        // and we might need to create it, so use `source` and give\n        // it the required parameters for a sourcemapped source.\n        return new OriginalLocation(\n          originalUrl ? this.source({\n            originalUrl: originalUrl,\n            generatedSource: source\n          }) : null,\n          originalLine,\n          originalColumn,\n          originalName\n        );\n      }\n\n      // No source map\n      return OriginalLocation.fromGeneratedLocation(generatedLocation);\n    });\n  },\n\n  getAllGeneratedLocations: function (originalLocation) {\n    let {\n      originalSourceActor,\n      originalLine,\n      originalColumn\n    } = originalLocation;\n\n    let source = originalSourceActor.source ||\n                 originalSourceActor.generatedSource;\n\n    return this.fetchSourceMap(source).then((map) => {\n      if (map) {\n        map.computeColumnSpans();\n\n        return map.allGeneratedPositionsFor({\n          source: originalSourceActor.url,\n          line: originalLine,\n          column: originalColumn\n        }).map(({ line, column, lastColumn }) => {\n          return new GeneratedLocation(\n            this.createNonSourceMappedActor(source),\n            line,\n            column,\n            lastColumn\n          );\n        });\n      }\n\n      return [GeneratedLocation.fromOriginalLocation(originalLocation)];\n    });\n  },\n\n\n  /**\n   * Returns a promise of the location in the generated source corresponding to\n   * the original source and line given.\n   *\n   * When we pass a script S representing generated code to `sourceMap`,\n   * above, that returns a promise P. The process of resolving P populates\n   * the tables this function uses; thus, it won't know that S's original\n   * source URLs map to S until P is resolved.\n   */\n  getGeneratedLocation: function (originalLocation) {\n    let { originalSourceActor } = originalLocation;\n\n    // Both original sources and normal sources could have sourcemaps,\n    // because normal sources can be pretty-printed which generates a\n    // sourcemap for itself. Check both of the source properties to make it work\n    // for both kinds of sources.\n    let source = originalSourceActor.source || originalSourceActor.generatedSource;\n\n    // See comment about `fetchSourceMap` in `getOriginalLocation`.\n    return this.fetchSourceMap(source).then((map) => {\n      if (map) {\n        let {\n          originalLine,\n          originalColumn\n        } = originalLocation;\n\n        let {\n          line: generatedLine,\n          column: generatedColumn\n        } = map.generatedPositionFor({\n          source: originalSourceActor.url,\n          line: originalLine,\n          column: originalColumn == null ? 0 : originalColumn,\n          bias: SourceMapConsumer.LEAST_UPPER_BOUND\n        });\n\n        return new GeneratedLocation(\n          this.createNonSourceMappedActor(source),\n          generatedLine,\n          generatedColumn\n        );\n      }\n\n      return GeneratedLocation.fromOriginalLocation(originalLocation);\n    });\n  },\n\n  /**\n   * Returns true if URL for the given source is black boxed.\n   *\n   * @param aURL String\n   *        The URL of the source which we are checking whether it is black\n   *        boxed or not.\n   */\n  isBlackBoxed: function (aURL) {\n    return this.blackBoxedSources.has(aURL);\n  },\n\n  /**\n   * Add the given source URL to the set of sources that are black boxed.\n   *\n   * @param aURL String\n   *        The URL of the source which we are black boxing.\n   */\n  blackBox: function (aURL) {\n    this.blackBoxedSources.add(aURL);\n  },\n\n  /**\n   * Remove the given source URL to the set of sources that are black boxed.\n   *\n   * @param aURL String\n   *        The URL of the source which we are no longer black boxing.\n   */\n  unblackBox: function (aURL) {\n    this.blackBoxedSources.delete(aURL);\n  },\n\n  /**\n   * Returns true if the given URL is pretty printed.\n   *\n   * @param aURL String\n   *        The URL of the source that might be pretty printed.\n   */\n  isPrettyPrinted: function (aURL) {\n    return this.prettyPrintedSources.has(aURL);\n  },\n\n  /**\n   * Add the given URL to the set of sources that are pretty printed.\n   *\n   * @param aURL String\n   *        The URL of the source to be pretty printed.\n   */\n  prettyPrint: function (aURL, aIndent) {\n    this.prettyPrintedSources.set(aURL, aIndent);\n  },\n\n  /**\n   * Return the indent the given URL was pretty printed by.\n   */\n  prettyPrintIndent: function (aURL) {\n    return this.prettyPrintedSources.get(aURL);\n  },\n\n  /**\n   * Remove the given URL from the set of sources that are pretty printed.\n   *\n   * @param aURL String\n   *        The URL of the source that is no longer pretty printed.\n   */\n  disablePrettyPrint: function (aURL) {\n    this.prettyPrintedSources.delete(aURL);\n  },\n\n  /**\n   * Normalize multiple relative paths towards the base paths on the right.\n   */\n  _normalize: function (...aURLs) {\n    dbg_assert(aURLs.length > 1, \"Should have more than 1 URL\");\n    let base = Services.io.newURI(aURLs.pop(), null, null);\n    let url;\n    while ((url = aURLs.pop())) {\n      base = Services.io.newURI(url, null, base);\n    }\n    return base.spec;\n  },\n\n  iter: function () {\n    let actors = Object.keys(this._sourceMappedSourceActors).map(k => {\n      return this._sourceMappedSourceActors[k];\n    });\n    for (let actor of this._sourceActors.values()) {\n      if (!this._sourceMaps.has(actor.source)) {\n        actors.push(actor);\n      }\n    }\n    return actors;\n  }\n};\n\n/*\n * Checks if a source should never be displayed to the user because\n * it's either internal or we don't support in the UI yet.\n */\nfunction isHiddenSource(aSource) {\n  // Ignore the internal Function.prototype script\n  return aSource.text === '() {\\n}';\n}\n\n/**\n * Returns true if its argument is not null.\n */\nfunction isNotNull(aThing) {\n  return aThing !== null;\n}\n\nexports.TabSources = TabSources;\nexports.isHiddenSource = isHiddenSource;\n"]}