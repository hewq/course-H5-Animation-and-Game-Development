{"version":3,"sources":["../../../../../../../../../../assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger/assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger/transport.js"],"names":["PACKET_HEADER_MAX","DebuggerTransport","input","output","_input","_output","_incomingHeader","_incoming","_outgoing","hooks","active","_incomingEnabled","_outgoingEnabled","close","bind","prototype","send","object","data","JSON","stringify","data_for_len","DevToolsUtils","utf16to8","length","_flushOutgoing","startBulkSend","header","emit","packet","BulkPacket","push","streamReadyForWriting","reason","_scriptableInput","_destroyIncoming","_destroyAllOutgoing","onClosed","dumpn","safeErrorString","_currentOutgoing","done","_finishCurrentOutgoing","_bufferWrite","pauseOutgoing","resumeOutgoing","onOutputStreamReady","makeInfallible","stream","write","e","result","Cr","NS_BASE_STREAM_WOULD_BLOCK","destroy","shift","ready","_waitForIncoming","pauseIncoming","resumeIncoming","_flushIncoming","onInputStreamReady","available","_processIncoming","count","dumpv","_readHeader","Packet","fromHeader","Error","read","msg","stack","amountToRead","StreamUtils","delimitedRead","wantVerbose","endsWith","wantLogging","_onJSONObjectReady","executeSoon","onPacket","_onBulkReadReady","args","onBulkPacket","LocalDebuggerTransport","other","_serial","serial","_deepFreeze","log","actor","type","pipe","Pipe","deferred","promise","defer","copyTo","copying","copyStream","inputStream","resolve","then","sendDeferred","copyDeferred","copyFrom","outputStream","ex","Cu","reportError","Object","freeze","prop","hasOwnProperty","isFrozen","o"],"mappings":"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","file":"transport.js","sourceRoot":"../../../../../../../../../../assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger","sourcesContent":["/****************************************************************************\n Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.\n \n http://www.cocos2d-x.org\n \n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n \n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n \n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n ****************************************************************************/\n\n/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */\n/* vim: set ft=javascript ts=2 et sw=2 tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n// TODO: Get rid of this code once the marionette server loads transport.js as\n// an SDK module (see bug 1000814)\n// (function (factory) { // Module boilerplate\n//   if (this.module && module.id.indexOf(\"transport\") >= 0) { // require\n//     factory.call(this, require, exports);\n//   } else { // loadSubScript\n//     if (this.require) {\n//       factory.call(this, require, this);\n//     } else {\n//       const Cu = Components.utils;\n//       const { require } = Cu.import(\"resource://gre/modules/devtools/Loader.jsm\", {});\n//       factory.call(this, require, this);\n//     }\n//   }\n// }).call(this, function (require, exports) {\n\n\"use strict\";\n\n// const { Cc, Ci, Cr, Cu, CC } = require(\"chrome\");\n// const Services = require(\"Services\");\n// const DevToolsUtils = require(\"devtools/toolkit/DevToolsUtils\");\n// const { dumpn, dumpv } = DevToolsUtils;\n// const StreamUtils = require(\"devtools/toolkit/transport/stream-utils\");\n// const { Packet, JSONPacket, BulkPacket } =\n//   require(\"devtools/toolkit/transport/packets\");\n// const promise = require(\"promise\");\n// const EventEmitter = require(\"devtools/toolkit/event-emitter\");\n\n// DevToolsUtils.defineLazyGetter(this, \"Pipe\", () => {\n//   return CC(\"@mozilla.org/pipe;1\", \"nsIPipe\", \"init\");\n// });\n\n// DevToolsUtils.defineLazyGetter(this, \"ScriptableInputStream\", () => {\n//   return CC(\"@mozilla.org/scriptableinputstream;1\",\n//             \"nsIScriptableInputStream\", \"init\");\n// });\n\nconst PACKET_HEADER_MAX = 200;\n\n/**\n * An adapter that handles data transfers between the debugger client and\n * server. It can work with both nsIPipe and nsIServerSocket transports so\n * long as the properly created input and output streams are specified.\n * (However, for intra-process connections, LocalDebuggerTransport, below,\n * is more efficient than using an nsIPipe pair with DebuggerTransport.)\n *\n * @param input nsIAsyncInputStream\n *        The input stream.\n * @param output nsIAsyncOutputStream\n *        The output stream.\n *\n * Given a DebuggerTransport instance dt:\n * 1) Set dt.hooks to a packet handler object (described below).\n * 2) Call dt.ready() to begin watching for input packets.\n * 3) Call dt.send() / dt.startBulkSend() to send packets.\n * 4) Call dt.close() to close the connection, and disengage from the event\n *    loop.\n *\n * A packet handler is an object with the following methods:\n *\n * - onPacket(packet) - called when we have received a complete packet.\n *   |packet| is the parsed form of the packet --- a JavaScript value, not\n *   a JSON-syntax string.\n *\n * - onBulkPacket(packet) - called when we have switched to bulk packet\n *   receiving mode. |packet| is an object containing:\n *   * actor:  Name of actor that will receive the packet\n *   * type:   Name of actor's method that should be called on receipt\n *   * length: Size of the data to be read\n *   * stream: This input stream should only be used directly if you can ensure\n *             that you will read exactly |length| bytes and will not close the\n *             stream when reading is complete\n *   * done:   If you use the stream directly (instead of |copyTo| below), you\n *             must signal completion by resolving / rejecting this deferred.\n *             If it's rejected, the transport will be closed.  If an Error is\n *             supplied as a rejection value, it will be logged via |dumpn|.\n *             If you do use |copyTo|, resolving is taken care of for you when\n *             copying completes.\n *   * copyTo: A helper function for getting your data out of the stream that\n *             meets the stream handling requirements above, and has the\n *             following signature:\n *     @param  output nsIAsyncOutputStream\n *             The stream to copy to.\n *     @return Promise\n *             The promise is resolved when copying completes or rejected if any\n *             (unexpected) errors occur.\n *             This object also emits \"progress\" events for each chunk that is\n *             copied.  See stream-utils.js.\n *\n * - onClosed(reason) - called when the connection is closed. |reason| is\n *   an optional nsresult or object, typically passed when the transport is\n *   closed due to some error in a underlying stream.\n *\n * See ./packets.js and the Remote Debugging Protocol specification for more\n * details on the format of these packets.\n */\nfunction DebuggerTransport(input, output) {\n  // EventEmitter.decorate(this);\n\n  this._input = input;\n  // this._scriptableInput = new ScriptableInputStream(input);\n  this._output = output;\n\n  // The current incoming (possibly partial) header, which will determine which\n  // type of Packet |_incoming| below will become.\n  this._incomingHeader = \"\";\n  // The current incoming Packet object\n  // this._incoming = null;\n  this._incoming = \"\";\n  // A queue of outgoing Packet objects\n  // this._outgoing = [];\n  this._outgoing = \"\";\n\n  this.hooks = null;\n  this.active = false;\n\n  this._incomingEnabled = true;\n  this._outgoingEnabled = true;\n\n  this.close = this.close.bind(this);\n}\n\nDebuggerTransport.prototype = {\n  /**\n   * Transmit an object as a JSON packet.\n   *\n   * This method returns immediately, without waiting for the entire\n   * packet to be transmitted, registering event handlers as needed to\n   * transmit the entire packet. Packets are transmitted in the order\n   * they are passed to this method.\n   */\n  send: function(object) {\n    // this.emit(\"send\", object);\n\n    // let packet = new JSONPacket(this);\n    // packet.object = object;\n    // this._outgoing.push(packet);\n\n    let data = JSON.stringify(object);\n    let data_for_len = DevToolsUtils.utf16to8(data);\n    this._outgoing = data_for_len.length + ':' + data;\n    this._flushOutgoing();\n  },\n\n  /**\n   * Transmit streaming data via a bulk packet.\n   *\n   * This method initiates the bulk send process by queuing up the header data.\n   * The caller receives eventual access to a stream for writing.\n   *\n   * N.B.: Do *not* attempt to close the stream handed to you, as it will\n   * continue to be used by this transport afterwards.  Most users should\n   * instead use the provided |copyFrom| function instead.\n   *\n   * @param header Object\n   *        This is modeled after the format of JSON packets above, but does not\n   *        actually contain the data, but is instead just a routing header:\n   *          * actor:  Name of actor that will receive the packet\n   *          * type:   Name of actor's method that should be called on receipt\n   *          * length: Size of the data to be sent\n   * @return Promise\n   *         The promise will be resolved when you are allowed to write to the\n   *         stream with an object containing:\n   *           * stream:   This output stream should only be used directly if\n   *                       you can ensure that you will write exactly |length|\n   *                       bytes and will not close the stream when writing is\n   *                       complete\n   *           * done:     If you use the stream directly (instead of |copyFrom|\n   *                       below), you must signal completion by resolving /\n   *                       rejecting this deferred.  If it's rejected, the\n   *                       transport will be closed.  If an Error is supplied as\n   *                       a rejection value, it will be logged via |dumpn|.  If\n   *                       you do use |copyFrom|, resolving is taken care of for\n   *                       you when copying completes.\n   *           * copyFrom: A helper function for getting your data onto the\n   *                       stream that meets the stream handling requirements\n   *                       above, and has the following signature:\n   *             @param  input nsIAsyncInputStream\n   *                     The stream to copy from.\n   *             @return Promise\n   *                     The promise is resolved when copying completes or\n   *                     rejected if any (unexpected) errors occur.\n   *                     This object also emits \"progress\" events for each chunk\n   *                     that is copied.  See stream-utils.js.\n   */\n  startBulkSend: function(header) {\n    this.emit(\"startBulkSend\", header);\n\n    let packet = new BulkPacket(this);\n    packet.header = header;\n    this._outgoing.push(packet);\n    this._flushOutgoing();\n    return packet.streamReadyForWriting;\n  },\n\n  /**\n   * Close the transport.\n   * @param reason nsresult / object (optional)\n   *        The status code or error message that corresponds to the reason for\n   *        closing the transport (likely because a stream closed or failed).\n   */\n  close: function(reason) {\n    this.emit(\"onClosed\", reason);\n\n    this.active = false;\n    this._input.close();\n    this._scriptableInput.close();\n    this._output.close();\n    this._destroyIncoming();\n    this._destroyAllOutgoing();\n    if (this.hooks) {\n      this.hooks.onClosed(reason);\n      this.hooks = null;\n    }\n    if (reason) {\n      dumpn(\"Transport closed: \" + DevToolsUtils.safeErrorString(reason));\n    } else {\n      dumpn(\"Transport closed.\");\n    }\n  },\n\n  /**\n   * The currently outgoing packet (at the top of the queue).\n   */\n  get _currentOutgoing() { return this._outgoing[0]; },\n\n  /**\n   * Flush data to the outgoing stream.  Waits until the output stream notifies\n   * us that it is ready to be written to (via onOutputStreamReady).\n   */\n  _flushOutgoing: function() {\n    if (!this._outgoingEnabled || this._outgoing.length === 0) {\n      return;\n    }\n\n    // If the top of the packet queue has nothing more to send, remove it.\n    if (this._currentOutgoing.done) {\n      this._finishCurrentOutgoing();\n    }\n\n    if (this._outgoing.length > 0) {\n      // var threadManager = Cc[\"@mozilla.org/thread-manager;1\"].getService();\n      // this._output.asyncWait(this, 0, 0, threadManager.currentThread);\n      // log('send: ' + this._outgoing);\n      _bufferWrite(this._outgoing);\n    }\n  },\n\n  /**\n   * Pause this transport's attempts to write to the output stream.  This is\n   * used when we've temporarily handed off our output stream for writing bulk\n   * data.\n   */\n  pauseOutgoing: function() {\n    this._outgoingEnabled = false;\n  },\n\n  /**\n   * Resume this transport's attempts to write to the output stream.\n   */\n  resumeOutgoing: function() {\n    this._outgoingEnabled = true;\n    this._flushOutgoing();\n  },\n\n  // nsIOutputStreamCallback\n  /**\n   * This is called when the output stream is ready for more data to be written.\n   * The current outgoing packet will attempt to write some amount of data, but\n   * may not complete.\n   */\n  onOutputStreamReady: DevToolsUtils.makeInfallible(function(stream) {\n    if (!this._outgoingEnabled || this._outgoing.length === 0) {\n      return;\n    }\n\n    try {\n      this._currentOutgoing.write(stream);\n    } catch(e) {\n      if (e.result != Cr.NS_BASE_STREAM_WOULD_BLOCK) {\n        this.close(e.result);\n        return;\n      } else {\n        throw e;\n      }\n    }\n\n    this._flushOutgoing();\n  }, \"DebuggerTransport.prototype.onOutputStreamReady\"),\n\n  /**\n   * Remove the current outgoing packet from the queue upon completion.\n   */\n  _finishCurrentOutgoing: function() {\n    if (this._currentOutgoing) {\n      this._currentOutgoing.destroy();\n      this._outgoing.shift();\n    }\n  },\n\n  /**\n   * Clear the entire outgoing queue.\n   */\n  _destroyAllOutgoing: function() {\n    for (let packet of this._outgoing) {\n      packet.destroy();\n    }\n    this._outgoing = [];\n  },\n\n  /**\n   * Initialize the input stream for reading. Once this method has been called,\n   * we watch for packets on the input stream, and pass them to the appropriate\n   * handlers via this.hooks.\n   */\n  ready: function() {\n    this.active = true;\n    this._waitForIncoming();\n  },\n\n  /**\n   * Asks the input stream to notify us (via onInputStreamReady) when it is\n   * ready for reading.\n   */\n  _waitForIncoming: function() {\n    // if (this._incomingEnabled) {\n    //   let threadManager = Cc[\"@mozilla.org/thread-manager;1\"].getService();\n    //   this._input.asyncWait(this, 0, 0, threadManager.currentThread);\n    // }\n  },\n\n  /**\n   * Pause this transport's attempts to read from the input stream.  This is\n   * used when we've temporarily handed off our input stream for reading bulk\n   * data.\n   */\n  pauseIncoming: function() {\n    this._incomingEnabled = false;\n  },\n\n  /**\n   * Resume this transport's attempts to read from the input stream.\n   */\n  resumeIncoming: function() {\n    this._incomingEnabled = true;\n    this._flushIncoming();\n    this._waitForIncoming();\n  },\n\n  // nsIInputStreamCallback\n  /**\n   * Called when the stream is either readable or closed.\n   */\n  onInputStreamReady:\n  DevToolsUtils.makeInfallible(function(stream) {\n    try {\n      while(stream.available() && this._incomingEnabled &&\n            this._processIncoming(stream, stream.available())) {}\n      this._waitForIncoming();\n    } catch(e) {\n      if (e.result != Cr.NS_BASE_STREAM_WOULD_BLOCK) {\n        this.close(e.result);\n      } else {\n        throw e;\n      }\n    }\n  }, \"DebuggerTransport.prototype.onInputStreamReady\"),\n\n  /**\n   * Process the incoming data.  Will create a new currently incoming Packet if\n   * needed.  Tells the incoming Packet to read as much data as it can, but\n   * reading may not complete.  The Packet signals that its data is ready for\n   * delivery by calling one of this transport's _on*Ready methods (see\n   * ./packets.js and the _on*Ready methods below).\n   * @return boolean\n   *         Whether incoming stream processing should continue for any\n   *         remaining data.\n   */\n  _processIncoming: function(stream, count) {\n    dumpv(\"Data available: \" + count);\n\n    if (!count) {\n      dumpv(\"Nothing to read, skipping\");\n      return false;\n    }\n\n    try {\n      if (!this._incoming) {\n        dumpv(\"Creating a new packet from incoming\");\n\n        if (!this._readHeader(stream)) {\n          return false; // Not enough data to read packet type\n        }\n\n        // Attempt to create a new Packet by trying to parse each possible\n        // header pattern.\n        this._incoming = Packet.fromHeader(this._incomingHeader, this);\n        if (!this._incoming) {\n          throw new Error(\"No packet types for header: \" +\n                          this._incomingHeader);\n        }\n      }\n\n      if (!this._incoming.done) {\n        // We have an incomplete packet, keep reading it.\n        dumpv(\"Existing packet incomplete, keep reading\");\n        this._incoming.read(stream, this._scriptableInput);\n      }\n    } catch(e) {\n      let msg = \"Error reading incoming packet: (\" + e + \" - \" + e.stack + \")\";\n      dumpn(msg);\n\n      // Now in an invalid state, shut down the transport.\n      this.close();\n      return false;\n    }\n\n    if (!this._incoming.done) {\n      // Still not complete, we'll wait for more data.\n      dumpv(\"Packet not done, wait for more\");\n      return true;\n    }\n\n    // Ready for next packet\n    this._flushIncoming();\n    return true;\n  },\n\n  /**\n   * Read as far as we can into the incoming data, attempting to build up a\n   * complete packet header (which terminates with \":\").  We'll only read up to\n   * PACKET_HEADER_MAX characters.\n   * @return boolean\n   *         True if we now have a complete header.\n   */\n  _readHeader: function() {\n    let amountToRead = PACKET_HEADER_MAX - this._incomingHeader.length;\n    this._incomingHeader +=\n      StreamUtils.delimitedRead(this._scriptableInput, \":\", amountToRead);\n    if (dumpv.wantVerbose) {\n      dumpv(\"Header read: \" + this._incomingHeader);\n    }\n\n    if (this._incomingHeader.endsWith(\":\")) {\n      if (dumpv.wantVerbose) {\n        dumpv(\"Found packet header successfully: \" + this._incomingHeader);\n      }\n      return true;\n    }\n\n    if (this._incomingHeader.length >= PACKET_HEADER_MAX) {\n      throw new Error(\"Failed to parse packet header!\");\n    }\n\n    // Not enough data yet.\n    return false;\n  },\n\n  /**\n   * If the incoming packet is done, log it as needed and clear the buffer.\n   */\n  _flushIncoming: function() {\n    if (!this._incoming.done) {\n      return;\n    }\n    if (dumpn.wantLogging) {\n      dumpn(\"Got: \" + this._incoming);\n    }\n    this._destroyIncoming();\n  },\n\n  /**\n   * Handler triggered by an incoming JSONPacket completing it's |read| method.\n   * Delivers the packet to this.hooks.onPacket.\n   */\n  _onJSONObjectReady: function(object) {\n    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {\n      // Ensure the transport is still alive by the time this runs.\n      if (this.active) {\n        this.emit(\"onPacket\", object);\n        this.hooks.onPacket(object);\n      }\n    }, \"DebuggerTransport instance's this.hooks.onPacket\"));\n  },\n\n  /**\n   * Handler triggered by an incoming BulkPacket entering the |read| phase for\n   * the stream portion of the packet.  Delivers info about the incoming\n   * streaming data to this.hooks.onBulkPacket.  See the main comment on the\n   * transport at the top of this file for more details.\n   */\n  _onBulkReadReady: function(...args) {\n    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {\n      // Ensure the transport is still alive by the time this runs.\n      if (this.active) {\n        this.emit(\"onBulkPacket\", ...args);\n        this.hooks.onBulkPacket(...args);\n      }\n    }, \"DebuggerTransport instance's this.hooks.onBulkPacket\"));\n  },\n\n  /**\n   * Remove all handlers and references related to the current incoming packet,\n   * either because it is now complete or because the transport is closing.\n   */\n  _destroyIncoming: function() {\n    if (this._incoming) {\n      this._incoming.destroy();\n    }\n    this._incomingHeader = \"\";\n    this._incoming = null;\n  }\n\n};\n\n// exports.DebuggerTransport = DebuggerTransport;\n\n/**\n * An adapter that handles data transfers between the debugger client and\n * server when they both run in the same process. It presents the same API as\n * DebuggerTransport, but instead of transmitting serialized messages across a\n * connection it merely calls the packet dispatcher of the other side.\n *\n * @param other LocalDebuggerTransport\n *        The other endpoint for this debugger connection.\n *\n * @see DebuggerTransport\n */\nfunction LocalDebuggerTransport(other) {\n  // EventEmitter.decorate(this);\n\n  this.other = other;\n  this.hooks = null;\n\n  /*\n   * A packet number, shared between this and this.other. This isn't used\n   * by the protocol at all, but it makes the packet traces a lot easier to\n   * follow.\n   */\n  this._serial = this.other ? this.other._serial : { count: 0 };\n  this.close = this.close.bind(this);\n}\n\nLocalDebuggerTransport.prototype = {\n  /**\n   * Transmit a message by directly calling the onPacket handler of the other\n   * endpoint.\n   */\n  send: function(packet) {\n    // this.emit(\"send\", packet);\n\n    let serial = this._serial.count++;\n    // if (dumpn.wantLogging) {\n    //   /* Check 'from' first, as 'echo' packets have both. */\n    //   if (packet.from) {\n    //     dumpn(\"Packet \" + serial + \" sent from \" + uneval(packet.from));\n    //   } else if (packet.to) {\n    //     dumpn(\"Packet \" + serial + \" sent to \" + uneval(packet.to));\n    //   }\n    // }\n    this._deepFreeze(packet);\n    let other = this.other;\n    if (other && other.hooks) {\n      log(\"Received packet \" + serial + \": \" + JSON.stringify(packet, null, 2));\n      other.hooks.onPacket(packet);\n    }\n    // if (other) {\n    //   DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {\n    //     // Avoid the cost of JSON.stringify() when logging is disabled.\n    //     if (dumpn.wantLogging) {\n    //       dumpn(\"Received packet \" + serial + \": \" + JSON.stringify(packet, null, 2));\n    //     }\n    //     if (other.hooks) {\n    //       other.emit(\"onPacket\", packet);\n    //       other.hooks.onPacket(packet);\n    //     }\n    //   }, \"LocalDebuggerTransport instance's this.other.hooks.onPacket\"));\n    // }\n  },\n\n  /**\n   * Send a streaming bulk packet directly to the onBulkPacket handler of the\n   * other endpoint.\n   *\n   * This case is much simpler than the full DebuggerTransport, since there is\n   * no primary stream we have to worry about managing while we hand it off to\n   * others temporarily.  Instead, we can just make a single use pipe and be\n   * done with it.\n   */\n  startBulkSend: function({actor, type, length}) {\n    this.emit(\"startBulkSend\", {actor, type, length});\n\n    let serial = this._serial.count++;\n\n    dumpn(\"Sent bulk packet \" + serial + \" for actor \" + actor);\n    if (!this.other) {\n      return;\n    }\n\n    let pipe = new Pipe(true, true, 0, 0, null);\n\n    DevToolsUtils.executeSoon(DevToolsUtils.makeInfallible(() => {\n      dumpn(\"Received bulk packet \" + serial);\n      if (!this.other.hooks) {\n        return;\n      }\n\n      // Receiver\n      let deferred = promise.defer();\n      let packet = {\n        actor: actor,\n        type: type,\n        length: length,\n        copyTo: (output) => {\n          let copying =\n            StreamUtils.copyStream(pipe.inputStream, output, length);\n          deferred.resolve(copying);\n          return copying;\n        },\n        stream: pipe.inputStream,\n        done: deferred\n      };\n\n      this.other.emit(\"onBulkPacket\", packet);\n      this.other.hooks.onBulkPacket(packet);\n\n      // Await the result of reading from the stream\n      deferred.promise.then(() => pipe.inputStream.close(), this.close);\n    }, \"LocalDebuggerTransport instance's this.other.hooks.onBulkPacket\"));\n\n    // Sender\n    let sendDeferred = promise.defer();\n\n    // The remote transport is not capable of resolving immediately here, so we\n    // shouldn't be able to either.\n    DevToolsUtils.executeSoon(() => {\n      let copyDeferred = promise.defer();\n\n      sendDeferred.resolve({\n        copyFrom: (input) => {\n          let copying =\n            StreamUtils.copyStream(input, pipe.outputStream, length);\n          copyDeferred.resolve(copying);\n          return copying;\n        },\n        stream: pipe.outputStream,\n        done: copyDeferred\n      });\n\n      // Await the result of writing to the stream\n      copyDeferred.promise.then(() => pipe.outputStream.close(), this.close);\n    });\n\n    return sendDeferred.promise;\n  },\n\n  /**\n   * Close the transport.\n   */\n  close: function() {\n    this.emit(\"close\");\n\n    if (this.other) {\n      // Remove the reference to the other endpoint before calling close(), to\n      // avoid infinite recursion.\n      let other = this.other;\n      this.other = null;\n      other.close();\n    }\n    if (this.hooks) {\n      try {\n        this.hooks.onClosed();\n      } catch(ex) {\n        Cu.reportError(ex);\n      }\n      this.hooks = null;\n    }\n  },\n\n  /**\n   * An empty method for emulating the DebuggerTransport API.\n   */\n  ready: function() {},\n\n  /**\n   * Helper function that makes an object fully immutable.\n   */\n  _deepFreeze: function(object) {\n    Object.freeze(object);\n    for (let prop in object) {\n      // Freeze the properties that are objects, not on the prototype, and not\n      // already frozen. Note that this might leave an unfrozen reference\n      // somewhere in the object if there is an already frozen object containing\n      // an unfrozen object.\n      if (object.hasOwnProperty(prop) && typeof object === \"object\" &&\n          !Object.isFrozen(object)) {\n        this._deepFreeze(o[prop]);\n      }\n    }\n  }\n};\n\n// exports.LocalDebuggerTransport = LocalDebuggerTransport;\n\n/**\n * A transport for the debugging protocol that uses nsIMessageSenders to\n * exchange packets with servers running in child processes.\n *\n * In the parent process, |sender| should be the nsIMessageSender for the\n * child process. In a child process, |sender| should be the child process\n * message manager, which sends packets to the parent.\n *\n * |prefix| is a string included in the message names, to distinguish\n * multiple servers running in the same child process.\n *\n * This transport exchanges messages named 'debug:<prefix>:packet', where\n * <prefix> is |prefix|, whose data is the protocol packet.\n */\n// function ChildDebuggerTransport(sender, prefix) {\n//   EventEmitter.decorate(this);\n\n//   this._sender = sender.QueryInterface(Ci.nsIMessageSender);\n//   this._messageName = \"debug:\" + prefix + \":packet\";\n// }\n\n// /*\n//  * To avoid confusion, we use 'message' to mean something that\n//  * nsIMessageSender conveys, and 'packet' to mean a remote debugging\n//  * protocol packet.\n//  */\n// ChildDebuggerTransport.prototype = {\n//   constructor: ChildDebuggerTransport,\n\n//   hooks: null,\n\n//   ready: function () {\n//     this._sender.addMessageListener(this._messageName, this);\n//   },\n\n//   close: function () {\n//     this._sender.removeMessageListener(this._messageName, this);\n//     this.emit(\"onClosed\");\n//     this.hooks.onClosed();\n//   },\n\n//   receiveMessage: function ({data}) {\n//     this.emit(\"onPacket\", data);\n//     this.hooks.onPacket(data);\n//   },\n\n//   send: function (packet) {\n//     this.emit(\"send\", packet);\n//     this._sender.sendAsyncMessage(this._messageName, packet);\n//   },\n\n//   startBulkSend: function() {\n//     throw new Error(\"Can't send bulk data to child processes.\");\n//   }\n// };\n\n// exports.ChildDebuggerTransport = ChildDebuggerTransport;\n\n// // WorkerDebuggerTransport is defined differently depending on whether we are\n// // on the main thread or a worker thread. In the former case, we are required\n// // by the devtools loader, and isWorker will be false. Otherwise, we are\n// // required by the worker loader, and isWorker will be true.\n// //\n// // Each worker debugger supports only a single connection to the main thread.\n// // However, its theoretically possible for multiple servers to connect to the\n// // same worker. Consequently, each transport has a connection id, to allow\n// // messages from multiple connections to be multiplexed on a single channel.\n\n// if (!this.isWorker) {\n//   (function () { // Main thread\n//     /**\n//      * A transport that uses a WorkerDebugger to send packets from the main\n//      * thread to a worker thread.\n//      */\n//     function WorkerDebuggerTransport(dbg, id) {\n//       this._dbg = dbg;\n//       this._id = id;\n//       this.onMessage = this._onMessage.bind(this);\n//     }\n\n//     WorkerDebuggerTransport.prototype = {\n//       constructor: WorkerDebuggerTransport,\n\n//       ready: function () {\n//         this._dbg.addListener(this);\n//       },\n\n//       close: function () {\n//         this._dbg.removeListener(this);\n//         if (this.hooks) {\n//           this.hooks.onClosed();\n//         }\n//       },\n\n//       send: function (packet) {\n//         this._dbg.postMessage(JSON.stringify({\n//           type: \"message\",\n//           id: this._id,\n//           message: packet\n//         }));\n//       },\n\n//       startBulkSend: function () {\n//         throw new Error(\"Can't send bulk data from worker threads!\");\n//       },\n\n//       _onMessage: function (message) {\n//         let packet = JSON.parse(message);\n//         if (packet.type !== \"message\" || packet.id !== this._id) {\n//           return;\n//         }\n\n//         if (this.hooks) {\n//           this.hooks.onPacket(packet.message);\n//         }\n//       }\n//     };\n\n//     exports.WorkerDebuggerTransport = WorkerDebuggerTransport;\n//   }).call(this);\n// } else {\n//   (function () { // Worker thread\n//     /*\n//      * A transport that uses a WorkerDebuggerGlobalScope to send packets from a\n//      * worker thread to the main thread.\n//      */\n//     function WorkerDebuggerTransport(scope, id) {\n//       this._scope = scope;\n//       this._id = id;\n//       this._onMessage = this._onMessage.bind(this);\n//     }\n\n//     WorkerDebuggerTransport.prototype = {\n//       constructor: WorkerDebuggerTransport,\n\n//       ready: function () {\n//         this._scope.addEventListener(\"message\", this._onMessage);\n//       },\n\n//       close: function () {\n//         this._scope.removeEventListener(\"message\", this._onMessage);\n//         if (this.hooks) {\n//           this.hooks.onClosed();\n//         }\n//       },\n\n//       send: function (packet) {\n//         this._scope.postMessage(JSON.stringify({\n//           type: \"message\",\n//           id: this._id,\n//           message: packet\n//         }));\n//       },\n\n//       startBulkSend: function () {\n//         throw new Error(\"Can't send bulk data from worker threads!\");\n//       },\n\n//       _onMessage: function (event) {\n//         let packet = JSON.parse(event.data);\n//         if (packet.type !== \"message\" || packet.id !== this._id) {\n//           return;\n//         }\n\n//         if (this.hooks) {\n//           this.hooks.onPacket(packet.message);\n//         }\n//       }\n//     };\n\n//     exports.WorkerDebuggerTransport = WorkerDebuggerTransport;\n//   }).call(this);\n// }\n\n// });\n"]}