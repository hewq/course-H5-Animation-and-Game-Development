{"version":3,"sources":["../../../../../../../../../../../assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger/core/assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger/core/promise.js"],"names":["exports","fulfilled","value","then","fulfill","rejected","reason","reject","isPromise","defer","prototype","observers","result","Object","promise","create","onFulfill","onError","deferred","resolve","error","_reportErrors","console","push","length","observer","shift","promised","call","Function","concat","Array","execute","args","apply","promisedConcat","promises","unknown","values","f","arguments","reduce","all"],"mappings":"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","file":"promise.js","sourceRoot":"../../../../../../../../../../../assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger/core","sourcesContent":["/****************************************************************************\n Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.\n \n http://www.cocos2d-x.org\n \n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n \n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n \n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n ****************************************************************************/\n\n//;(function(id, factory) { // Module boilerplate :(\n//  if (typeof(define) === 'function') { // RequireJS\n//    define(factory);\n//  } else if (typeof(require) === 'function') { // CommonJS\n//    factory.call(this, require, exports, module);\n//  } else if (String(this).indexOf('BackstagePass') >= 0) { // JSM\n//    this[factory.name] = {};\n//    try {\n//      this.console = this['Components'].utils\n//          .import('resource://gre/modules/devtools/Console.jsm', {}).console;\n//    }\n//    catch (ex) {\n//      // Avoid failures on different toolkit configurations.\n//    }\n//    factory(function require(uri) {\n//      var imports = {};\n//      this['Components'].utils.import(uri, imports);\n//      return imports;\n//    }, this[factory.name], { uri: __URI__, id: id });\n//    this.EXPORTED_SYMBOLS = [factory.name];\n//  } else {  // Browser or alike\n//    var globals = this;\n//    factory(function require(id) {\n//      return globals[id];\n//    }, (globals[id] = {}), { uri: document.location.href + '#' + id, id: id });\n//  }\n//}).call(this, 'promise/core', function Promise(require, exports, module) {\n\n'use strict';\n\nvar exports = exports || {};\n\n//module.metadata = {\n//  \"stability\": \"unstable\"\n//};\n\n/**\n * Internal utility: Wraps given `value` into simplified promise, successfully\n * fulfilled to a given `value`. Note the result is not a complete promise\n * implementation, as its method `then` does not returns anything.\n */\nfunction fulfilled(value) {\n  return { then: function then(fulfill) { fulfill(value); } };\n}\n\n/**\n * Internal utility: Wraps given input into simplified promise, pre-rejected\n * with a given `reason`. Note the result is not a complete promise\n * implementation, as its method `then` does not returns anything.\n */\nfunction rejected(reason) {\n  return { then: function then(fulfill, reject) { reject(reason); } };\n}\n\n/**\n * Internal utility: Returns `true` if given `value` is a promise. Value is\n * assumed to be a promise if it implements method `then`.\n */\nfunction isPromise(value) {\n  return value && typeof(value.then) === 'function';\n}\n\n/**\n * Creates deferred object containing fresh promise & methods to either resolve\n * or reject it. The result is an object with the following properties:\n * - `promise` Eventual value representation implementing CommonJS [Promises/A]\n *   (http://wiki.commonjs.org/wiki/Promises/A) API.\n * - `resolve` Single shot function that resolves enclosed `promise` with a\n *   given `value`.\n * - `reject` Single shot function that rejects enclosed `promise` with a given\n *   `reason`.\n *\n * An optional `prototype` argument is used as a prototype of the returned\n * `promise` allowing one to implement additional API. If prototype is not\n * passed then it falls back to `Object.prototype`.\n *\n *  ## Example\n *\n *  function fetchURI(uri, type) {\n *    var deferred = defer();\n *    var request = new XMLHttpRequest();\n *    request.open(\"GET\", uri, true);\n *    request.responseType = type;\n *    request.onload = function onload() {\n *      deferred.resolve(request.response);\n *    }\n *    request.onerror = function(event) {\n *     deferred.reject(event);\n *    }\n *    request.send();\n *\n *    return deferred.promise;\n *  }\n */\nfunction defer(prototype) {\n  // Define FIFO queue of observer pairs. Once promise is resolved & all queued\n  // observers are forwarded to `result` and variable is set to `null`.\n  var observers = [];\n\n  // Promise `result`, which will be assigned a resolution value once promise\n  // is resolved. Note that result will always be assigned promise (or alike)\n  // object to take care of propagation through promise chains. If result is\n  // `null` promise is not resolved yet.\n  var result = null;\n\n  prototype = (prototype || prototype === null) ? prototype : Object.prototype;\n\n  // Create an object implementing promise API.\n  var promise = Object.create(prototype, {\n    then: { value: function then(onFulfill, onError) {\n      var deferred = defer(prototype);\n\n      function resolve(value) {\n        // If `onFulfill` handler is provided resolve `deferred.promise` with\n        // result of invoking it with a resolution value. If handler is not\n        // provided propagate value through.\n        try {\n          deferred.resolve(onFulfill ? onFulfill(value) : value);\n        }\n        // `onFulfill` may throw exception in which case resulting promise\n        // is rejected with thrown exception.\n        catch(error) {\n          if (exports._reportErrors && typeof(console) === 'object')\n            console.error(error);\n          // Note: Following is equivalent of `deferred.reject(error)`,\n          // we use this shortcut to reduce a stack.\n          deferred.resolve(rejected(error));\n        }\n      }\n\n      function reject(reason) {\n        try {\n          if (onError) deferred.resolve(onError(reason));\n          else deferred.resolve(rejected(reason));\n        }\n        catch(error) {\n          if (exports._reportErrors && typeof(console) === 'object')\n            console.error(error);\n          deferred.resolve(rejected(error));\n        }\n      }\n\n      // If enclosed promise (`this.promise`) observers queue is still alive\n      // enqueue a new observer pair into it. Note that this does not\n      // necessary means that promise is pending, it may already be resolved,\n      // but we still have to queue observers to guarantee an order of\n      // propagation.\n      if (observers) {\n        observers.push({ resolve: resolve, reject: reject });\n      }\n      // Otherwise just forward observer pair right to a `result` promise.\n      else {\n        result.then(resolve, reject);\n      }\n\n      return deferred.promise;\n    }}\n  })\n\n  var deferred = {\n    promise: promise,\n    /**\n     * Resolves associated `promise` to a given `value`, unless it's already\n     * resolved or rejected. Note that resolved promise is not necessary a\n     * successfully fulfilled. Promise may be resolved with a promise `value`\n     * in which case `value` promise's fulfillment / rejection will propagate\n     * up to a promise resolved with `value`.\n     */\n    resolve: function resolve(value) {\n      if (!result) {\n        // Store resolution `value` in a `result` as a promise, so that all\n        // the subsequent handlers can be simply forwarded to it. Since\n        // `result` will be a promise all the value / error propagation will\n        // be uniformly taken care of.\n        result = isPromise(value) ? value : fulfilled(value);\n\n        // Forward already registered observers to a `result` promise in the\n        // order they were registered. Note that we intentionally dequeue\n        // observer at a time until queue is exhausted. This makes sure that\n        // handlers registered as side effect of observer forwarding are\n        // queued instead of being invoked immediately, guaranteeing FIFO\n        // order.\n        while (observers.length) {\n          var observer = observers.shift();\n          result.then(observer.resolve, observer.reject);\n        }\n\n        // Once `observers` queue is exhausted we `null`-ify it, so that\n        // new handlers are forwarded straight to the `result`.\n        observers = null;\n      }\n    },\n    /**\n     * Rejects associated `promise` with a given `reason`, unless it's already\n     * resolved / rejected. This is just a (better performing) convenience\n     * shortcut for `deferred.resolve(reject(reason))`.\n     */\n    reject: function reject(reason) {\n      // Note that if promise is resolved that does not necessary means that it\n      // is successfully fulfilled. Resolution value may be a promise in which\n      // case its result propagates. In other words if promise `a` is resolved\n      // with promise `b`, `a` is either fulfilled or rejected depending\n      // on weather `b` is fulfilled or rejected. Here `deferred.promise` is\n      // resolved with a promise pre-rejected with a given `reason`, there for\n      // `deferred.promise` is rejected with a given `reason`. This may feel\n      // little awkward first, but doing it this way greatly simplifies\n      // propagation through promise chains.\n      deferred.resolve(rejected(reason));\n    }\n  };\n\n  return deferred;\n}\nexports.defer = defer;\n\n/**\n * Returns a promise resolved to a given `value`. Optionally a second\n * `prototype` argument may be provided to be used as a prototype for the\n * returned promise.\n */\nfunction resolve(value, prototype) {\n  var deferred = defer(prototype);\n  deferred.resolve(value);\n  return deferred.promise;\n}\nexports.resolve = resolve;\n\n/**\n * Returns a promise rejected with a given `reason`. Optionally a second\n * `prototype` argument may be provided to be used as a prototype for the\n * returned promise.\n */\nfunction reject(reason, prototype) {\n  var deferred = defer(prototype);\n  deferred.reject(reason);\n  return deferred.promise;\n}\nexports.reject = reject;\n\nvar promised = (function() {\n  // Note: Define shortcuts and utility functions here in order to avoid\n  // slower property accesses and unnecessary closure creations on each\n  // call of this popular function.\n\n  var call = Function.call;\n  var concat = Array.prototype.concat;\n\n  // Utility function that does following:\n  // execute([ f, self, args...]) => f.apply(self, args)\n  function execute(args) { return call.apply(call, args) }\n\n  // Utility function that takes promise of `a` array and maybe promise `b`\n  // as arguments and returns promise for `a.concat(b)`.\n  function promisedConcat(promises, unknown) {\n    return promises.then(function(values) {\n      return resolve(unknown).then(function(value) {\n        return values.concat([ value ]);\n      });\n    });\n  }\n\n  return function promised(f, prototype) {\n    /**\n    Returns a wrapped `f`, which when called returns a promise that resolves to\n    `f(...)` passing all the given arguments to it, which by the way may be\n    promises. Optionally second `prototype` argument may be provided to be used\n    a prototype for a returned promise.\n\n    ## Example\n\n    var promise = promised(Array)(1, promise(2), promise(3))\n    promise.then(console.log) // => [ 1, 2, 3 ]\n    **/\n\n    return function promised() {\n      // create array of [ f, this, args... ]\n      return concat.apply([ f, this ], arguments).\n        // reduce it via `promisedConcat` to get promised array of fulfillments\n        reduce(promisedConcat, resolve([], prototype)).\n        // finally map that to promise of `f.apply(this, args...)`\n        then(execute);\n    };\n  }\n})();\nexports.promised = promised;\n//\nvar all = promised(Array);\nexports.all = all;\n//\n//});\n"]}