{"version":3,"sources":["../../../../../../../../../assets/frameworks/cocos2d-html5/extensions/cocostudio/armature/display/assets/frameworks/cocos2d-html5/extensions/cocostudio/armature/display/CCDisplayManager.js"],"names":["ccs","DisplayManager","Class","extend","_decoDisplayList","_currentDecoDisplay","_displayRenderNode","_displayIndex","_forceChangeDisplay","_bone","_visible","_displayType","ctor","bone","DISPLAY_TYPE_MAX","prototype","init","call","initDisplayList","getBoneData","addDisplay","display","index","decoDisplay","locDisplayList","length","DecorativeDisplay","push","DisplayData","displayFactory","changeDisplayWithIndex","displayData","Skin","setBone","SpriteDisplayData","initSpriteDisplay","getDisplayName","spriteDisplayData","getDisplayData","setSkinData","skinData","find","i","dd","sdd","BaseData","cc","ParticleSystem","ParticleDisplayData","removeFromParent","_performRecursive","Node","_stateCallbackType","cleanup","armature","getArmature","setParent","Armature","ArmatureDisplayData","displayName","getName","setParentBone","setDisplay","setDisplayData","_addDisplayOther","skin","_plistFile","removeDisplay","splice","setCurrentDecorativeDisplay","getDecorativeDisplayList","force","log","changeDisplayWithName","name","locCurrentDecoDisplay","ENABLE_PHYSICS_CHIPMUNK_DETECT","ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX","getColliderDetector","setActive","displayRenderNode","getDisplay","locRenderNode","locBone","setChildArmature","resetSystem","setColor","getDisplayedColor","setOpacity","getDisplayedOpacity","setVisible","displayType","renderer","childrenOrderDirty","getDisplayRenderNode","getDisplayRenderNodeType","getCurrentDisplayIndex","getCurrentDecorativeDisplay","getDecorativeDisplayByIndex","boneData","displayList","displayDataList","decoList","createDisplay","containPoint","point","y","undefined","p","DISPLAY_TYPE_SPRITE","sprite","getChildByTag","SPRITE_CONTAIN_POINT_WITH_RETURN","visible","isVisible","getContentSize","size","getBoundingBox","rect","getAnchorPoint","getAnchorPointInPoints","getForceChangeDisplay","release","create"],"mappings":"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","file":"CCDisplayManager.js","sourceRoot":"../../../../../../../../../assets/frameworks/cocos2d-html5/extensions/cocostudio/armature/display","sourcesContent":["/****************************************************************************\n Copyright (c) 2011-2012 cocos2d-x.org\n Copyright (c) 2013-2014 Chukong Technologies Inc.\n\n http://www.cocos2d-x.org\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n ****************************************************************************/\n\n/**\n * The display manager for CocoStudio Armature bone.\n * @Class ccs.DisplayManager\n * @extend cc.Class\n *\n * @param {ccs.Bone} bone The bone for the display manager\n */\nccs.DisplayManager = ccs.Class.extend(/** @lends ccs.DisplayManager */{\n    _decoDisplayList: null,\n    _currentDecoDisplay: null,\n    _displayRenderNode: null,\n    _displayIndex: null,\n    _forceChangeDisplay: false,\n    _bone: null,\n    _visible: true,\n    _displayType: null,\n\n    ctor: function (bone) {\n        this._decoDisplayList = [];\n        this._currentDecoDisplay = null;\n        this._displayRenderNode = null;\n        this._displayIndex = null;\n        this._forceChangeDisplay = false;\n        this._bone = null;\n        this._visible = true;\n        this._displayType = ccs.DISPLAY_TYPE_MAX;\n\n        bone && ccs.DisplayManager.prototype.init.call(this, bone);\n    },\n\n    /**\n     * Initializes a ccs.DisplayManager.\n     * @param bone\n     * @returns {boolean}\n     */\n    init: function (bone) {\n        this._bone = bone;\n        this.initDisplayList(bone.getBoneData());\n        return true;\n    },\n\n    /**\n     * <p>\n     *     Add display and use  _DisplayData init the display.                              <br/>\n     *     If index already have a display, then replace it.                                <br/>\n     *     If index is current display index, then also change display to _index            <br/>\n     * </p>\n     * @param {ccs.DisplayData|cc.Node} display it include the display information, like DisplayType. If you want to create a sprite display, then create a SpriteDisplayData param\n     * @param {Number} index  the index of the display you want to replace or add to. -1 : append display from back\n     */\n    addDisplay: function (display, index) {\n        var decoDisplay, locDisplayList = this._decoDisplayList;\n        if ((index >= 0) && (index < locDisplayList.length))\n            decoDisplay = locDisplayList[index];\n        else {\n            decoDisplay = new ccs.DecorativeDisplay();\n            locDisplayList.push(decoDisplay);\n        }\n\n        if (display instanceof ccs.DisplayData) {\n            ccs.displayFactory.addDisplay(this._bone, decoDisplay, display);\n            //! if changed display index is current display index, then change current display to the new display\n            if (index === this._displayIndex) {\n                this._displayIndex = -1;\n                this.changeDisplayWithIndex(index, false);\n            }\n            return;\n        }\n\n        var displayData = null;\n        if (display instanceof ccs.Skin) {\n            display.setBone(this._bone);\n            displayData = new ccs.SpriteDisplayData();\n            ccs.displayFactory.initSpriteDisplay(this._bone, decoDisplay, display.getDisplayName(), display);\n\n            var spriteDisplayData = decoDisplay.getDisplayData();\n            if (spriteDisplayData instanceof ccs.SpriteDisplayData) {\n                display.setSkinData(spriteDisplayData.skinData);\n                displayData.skinData = spriteDisplayData.skinData;\n            } else {\n                var find = false;\n                for (var i = locDisplayList.length - 2; i >= 0; i--) {\n                    var dd = locDisplayList[i];\n                    var sdd = dd.getDisplayData();\n                    if (sdd instanceof ccs.SpriteDisplayData) {\n                        find = true;\n                        display.setSkinData(sdd.skinData);\n                        displayData.skinData = sdd.skinData;\n                        break;\n                    }\n                }\n                if (!find)\n                    display.setSkinData(new ccs.BaseData());\n            }\n        } else if (display instanceof cc.ParticleSystem) {\n            displayData = new ccs.ParticleDisplayData();\n            display.removeFromParent();\n            display._performRecursive(cc.Node._stateCallbackType.cleanup);\n            var armature = this._bone.getArmature();\n            if (armature)\n                display.setParent(armature);\n        } else if (display instanceof ccs.Armature) {\n            displayData = new ccs.ArmatureDisplayData();\n            displayData.displayName = display.getName();\n            display.setParentBone(this._bone);\n        } else\n            displayData = new ccs.DisplayData();\n        decoDisplay.setDisplay(display);\n        decoDisplay.setDisplayData(displayData);\n\n        //! if changed display index is current display index, then change current display to the new display\n        if (index === this._displayIndex) {\n            this._displayIndex = -1;\n            this.changeDisplayWithIndex(index, false);\n        }\n    },\n\n    _addDisplayOther: function (decoDisplay, display) {\n        var displayData = null;\n        if (display instanceof ccs.Skin) {\n            var skin = display;\n            skin.setBone(this._bone);\n            displayData = new ccs.SpriteDisplayData();\n            displayData.displayName = skin.getDisplayName();\n            ccs.displayFactory.initSpriteDisplay(this._bone, decoDisplay, skin.getDisplayName(), skin);\n            var spriteDisplayData = decoDisplay.getDisplayData();\n            if (spriteDisplayData instanceof ccs.SpriteDisplayData)\n                skin.setSkinData(spriteDisplayData.skinData);\n            else {\n                var find = false;\n                for (var i = this._decoDisplayList.length - 2; i >= 0; i--) {\n                    var dd = this._decoDisplayList[i];\n                    var sdd = dd.getDisplayData();\n                    if (sdd) {\n                        find = true;\n                        skin.setSkinData(sdd.skinData);\n                        displayData.skinData = sdd.skinData;\n                        break;\n                    }\n                }\n                if (!find) {\n                    skin.setSkinData(new ccs.BaseData());\n                }\n                skin.setSkinData(new ccs.BaseData());\n            }\n                \n        }\n        else if (display instanceof cc.ParticleSystem) {\n            displayData = new ccs.ParticleDisplayData();\n            displayData.displayName = display._plistFile;\n        }\n        else if (display instanceof ccs.Armature) {\n            displayData = new ccs.ArmatureDisplayData();\n            displayData.displayName = display.getName();\n            display.setParentBone(this._bone);\n        }\n        else {\n            displayData = new ccs.DisplayData();\n        }\n        decoDisplay.setDisplay(display);\n        decoDisplay.setDisplayData(displayData);\n    },\n\n    /**\n     * Removes display node from list.\n     * @param {Number} index\n     */\n    removeDisplay: function (index) {\n        this._decoDisplayList.splice(index, 1);\n        if (index === this._displayIndex) {\n            this.setCurrentDecorativeDisplay(null);\n            this._displayIndex = -1;\n        }\n    },\n\n    /**\n     * Returns the display node list.\n     * @returns {Array}\n     */\n    getDecorativeDisplayList: function () {\n        return this._decoDisplayList;\n    },\n\n    /**\n     * <p>\n     *     Change display by index. You can just use this method to change display in the display list.            <br/>\n     *     The display list is just used for this bone, and it is the displays you may use in every frame.         <br/>\n     *     Note : if index is the same with prev index, the method will not effect                                 <br/>\n     * </p>\n     * @param {Number} index  The index of the display you want to change\n     * @param {Boolean} force  If true, then force change display to specified display, or current display will set to  display index edit in the flash every key frame.\n     */\n    changeDisplayWithIndex: function (index, force) {\n        if (index >= this._decoDisplayList.length) {\n            cc.log(\"the index value is out of range\");\n            return;\n        }\n        this._forceChangeDisplay = force;\n\n        //if index is equal to current display index,then do nothing\n        if (this._displayIndex === index)\n            return;\n\n        this._displayIndex = index;\n\n        //! If displayIndex < 0, it means you want to hide you display\n        if (index < 0) {\n            if (this._displayRenderNode) {\n                this._displayRenderNode.removeFromParent(true);\n                this.setCurrentDecorativeDisplay(null);\n            }\n            return;\n        }\n        this.setCurrentDecorativeDisplay(this._decoDisplayList[index]);\n    },\n\n    /**\n     * Change display by name. @see changeDisplayWithIndex.\n     * @param {String} name\n     * @param {Boolean} force\n     */\n    changeDisplayWithName: function (name, force) {\n        var locDisplayList = this._decoDisplayList;\n        for (var i = 0; i < locDisplayList.length; i++) {\n            if (locDisplayList[i].getDisplayData().displayName === name) {\n                this.changeDisplayWithIndex(i, force);\n                break;\n            }\n        }\n    },\n\n    /**\n     * Sets current decorative display.\n     * @param {ccs.DecorativeDisplay} decoDisplay\n     */\n    setCurrentDecorativeDisplay: function (decoDisplay) {\n        var locCurrentDecoDisplay = this._currentDecoDisplay;\n        if (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {\n            if (locCurrentDecoDisplay && locCurrentDecoDisplay.getColliderDetector())\n                locCurrentDecoDisplay.getColliderDetector().setActive(false);\n        }\n\n        this._currentDecoDisplay = decoDisplay;\n        locCurrentDecoDisplay = this._currentDecoDisplay;\n        if (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {\n            if (locCurrentDecoDisplay && locCurrentDecoDisplay.getColliderDetector())\n                locCurrentDecoDisplay.getColliderDetector().setActive(true);\n        }\n\n        var displayRenderNode = (!locCurrentDecoDisplay) ? null : locCurrentDecoDisplay.getDisplay();\n\n        var locRenderNode = this._displayRenderNode, locBone = this._bone;\n        if (locRenderNode) {\n            if (locRenderNode instanceof ccs.Armature)\n                locBone.setChildArmature(null);\n            locRenderNode.removeFromParent(true);\n        }\n        this._displayRenderNode = displayRenderNode;\n\n        if (displayRenderNode) {\n            if (displayRenderNode instanceof ccs.Armature) {\n                this._bone.setChildArmature(displayRenderNode);\n                displayRenderNode.setParentBone(this._bone);\n            } else if (displayRenderNode instanceof cc.ParticleSystem) {\n                if (displayRenderNode instanceof ccs.Armature) {\n                    locBone.setChildArmature(displayRenderNode);\n                    displayRenderNode.setParentBone(locBone);\n                } else if (displayRenderNode instanceof cc.ParticleSystem)\n                    displayRenderNode.resetSystem();\n            }\n\n            displayRenderNode.setColor(locBone.getDisplayedColor());\n            displayRenderNode.setOpacity(locBone.getDisplayedOpacity());\n\n            this._displayRenderNode.setVisible(this._visible);\n            this._displayType = this._currentDecoDisplay.getDisplayData().displayType;\n        } else\n            this._displayType = ccs.DISPLAY_TYPE_MAX;\n\n\n        cc.renderer.childrenOrderDirty = true;\n    },\n\n    /**\n     *  Returns the current display render node.\n     * @returns {cc.Node}\n     */\n    getDisplayRenderNode: function () {\n        return this._displayRenderNode;\n    },\n\n    /**\n     * Returns the type of display render node.\n     * @returns {Number}\n     */\n    getDisplayRenderNodeType: function () {\n        return this._displayType;\n    },\n\n    /**\n     * Returns the index of display render node.\n     * @returns {Number}\n     */\n    getCurrentDisplayIndex: function () {\n        return this._displayIndex;\n    },\n\n    /**\n     * Returns the current decorative display\n     * @returns {ccs.DecorativeDisplay}\n     */\n    getCurrentDecorativeDisplay: function () {\n        return this._currentDecoDisplay;\n    },\n\n    /**\n     * Gets a decorative display by index.\n     * @param index\n     * @returns {ccs.DecorativeDisplay}\n     */\n    getDecorativeDisplayByIndex: function (index) {\n        return this._decoDisplayList[index];\n    },\n\n    /**\n     * <p>\n     *  Use BoneData to init the display list.\n     *  If display is a sprite, and it have texture info in the TextureData, then use TextureData to init the display node's anchor point\n     *  If the display is a Armature, then create a new Armature\n     * </p>\n     * @param {ccs.BoneData} boneData\n     */\n    initDisplayList: function (boneData) {\n        this._decoDisplayList.length = 0;\n        if (!boneData)\n            return;\n        var displayList = boneData.displayDataList, decoList = this._decoDisplayList, locBone = this._bone;\n        for (var i = 0; i < displayList.length; i++) {\n            var displayData = displayList[i];\n            var decoDisplay = new ccs.DecorativeDisplay();\n            decoDisplay.setDisplayData(displayData);\n            ccs.displayFactory.createDisplay(locBone, decoDisplay);\n            decoList.push(decoDisplay);\n        }\n    },\n\n    /**\n     * Check if the position is inside the bone.\n     * @param {cc.Point|Number} point\n     * @param {Number} [y]\n     * @returns {boolean}\n     */\n    containPoint: function (point, y) {\n        if (!this._visible || this._displayIndex < 0)\n            return false;\n\n        if (y !== undefined)\n            point = cc.p(point, y);\n\n        if (this._currentDecoDisplay.getDisplayData().displayType === ccs.DISPLAY_TYPE_SPRITE) {\n            /*\n             *  First we first check if the point is in the sprite content rect. If false, then we continue to check\n             *  the contour point. If this step is also false, then we can say the bone not contain this point.\n             *\n             */\n            var sprite = this._currentDecoDisplay.getDisplay();\n            sprite = sprite.getChildByTag(0);\n            return ccs.SPRITE_CONTAIN_POINT_WITH_RETURN(sprite, point);\n        }\n        return false;\n    },\n\n    /**\n     * <p>\n     *  Sets whether the display is visible                                               <br/>\n     *  The default value is true, a node is default to visible\n     * </p>\n     * @param {boolean} visible\n     */\n    setVisible: function (visible) {\n        if (!this._displayRenderNode)\n            return;\n        this._visible = visible;\n        this._displayRenderNode.setVisible(visible);\n    },\n\n    /**\n     * Determines if the display is visible\n     * @returns {boolean} true if the node is visible, false if the node is hidden.\n     */\n    isVisible: function () {\n        return this._visible;\n    },\n\n    getContentSize: function () {\n        if (!this._displayRenderNode)\n            return cc.size(0, 0);\n        return this._displayRenderNode.getContentSize();\n    },\n\n    getBoundingBox: function () {\n        if (!this._displayRenderNode)\n            return cc.rect(0, 0, 0, 0);\n        return this._displayRenderNode.getBoundingBox();\n    },\n\n    getAnchorPoint: function () {\n        if (!this._displayRenderNode)\n            return cc.p(0, 0);\n        return this._displayRenderNode.getAnchorPoint();\n    },\n\n    getAnchorPointInPoints: function () {\n        if (!this._displayRenderNode)\n            return cc.p(0, 0);\n        return this._displayRenderNode.getAnchorPointInPoints();\n    },\n\n    getForceChangeDisplay: function () {\n        return this._forceChangeDisplay;\n    },\n\n    release: function () {\n        this._decoDisplayList = null;\n        if (this._displayRenderNode) {\n            this._displayRenderNode.removeFromParent(true);\n            this._displayRenderNode = null;\n        }\n    }\n});\n\n/**\n * Allocates and initializes a display manager with ccs.Bone.\n * @param {ccs.Bone} bone\n * @returns {ccs.DisplayManager}\n * @deprecated since v3.1, please use new construction instead\n */\nccs.DisplayManager.create = function (bone) {\n    return new ccs.DisplayManager(bone);\n};\n"]}