{"version":3,"sources":["../../../../../../../assets/frameworks/cocos2d-html5/cocos2d/progress-timer/assets/frameworks/cocos2d-html5/cocos2d/progress-timer/CCProgressTimerWebGLRenderCmd.js"],"names":["MAX_VERTEX_COUNT","cc","ProgressTimer","WebGLRenderCmd","renderableObject","_rootCtor","_needDraw","_progressDirty","_bl","p","_tr","_transformUpdating","initCmd","proto","prototype","Object","create","Node","constructor","transform","parentCmd","recursive","originTransform","sp","_node","_sprite","_renderCmd","lx","_offsetPosition","x","rx","_rect","width","by","y","ty","height","wt","_worldTransform","a","c","tx","b","d","_updateProgressData","rendering","ctx","node","context","_renderContext","_vertexDataCount","_glProgramState","apply","_shaderProgram","_updateProjectionUniform","blendFunc","_blendFunc","glBlendFunc","src","dst","glBindTexture2D","texture","bindBuffer","ARRAY_BUFFER","_vertexWebGLBuffer","enableVertexAttribArray","VERTEX_ATTRIB_POSITION","VERTEX_ATTRIB_COLOR","VERTEX_ATTRIB_TEX_COORDS","_vertexDataDirty","bufferSubData","_float32View","locVertexDataLen","V3F_C4B_T2F","BYTES_PER_ELEMENT","vertexAttribPointer","FLOAT","UNSIGNED_BYTE","_type","TYPE_RADIAL","drawArrays","TRIANGLE_FAN","TYPE_BAR","_reverseDirection","TRIANGLE_STRIP","g_NumberOfDraws","_syncStatus","flags","_dirtyFlags","locFlag","_dirtyFlag","parentNode","_cascadeColorEnabled","colorDirty","_cascadeOpacityEnabled","opacityDirty","transformDirty","spriteCmd","spriteFlag","_syncDisplayColor","_syncDisplayOpacity","_updateColor","textureDirty","updateStatus","_updateDisplayColor","_updateDisplayOpacity","getParentRenderCmd","orderDirty","releaseData","_vertexData","webglBuffer","setTimeout","deleteBuffer","_vertexArrayBuffer","createBuffer","vertexDataLen","ArrayBuffer","Float32Array","i","gl","bufferData","DYNAMIC_DRAW","shaderCache","programForKey","SHADER_SPRITE_POSITION_TEXTURECOLOR","resetVertexData","locType","_updateRadial","_updateBar","_updateProgress","setDirtyFlag","alpha","_percentage","locBarChangeRate","_barChangeRate","alphaOffset","pMult","min","pSub","_midPoint","max","pAdd","locVertexData","_textureCoordFromAlphaPoint","texCoords","_vertexFromAlphaPoint","vertices","locMidPoint","angle","PI","topMid","percentagePt","pRotateByAngle","index","hit","min_t","FLT_MAX","locProTextCoordsCount","TEXTURE_COORDS_COUNT","pIndex","edgePtA","_boundaryTexCoord","edgePtB","pLerp","retPoint","pLineIntersect","sameIndexCount","alphaPoint","locProTextCoords","TEXTURE_COORDS","coords","ax","ay","locSprite","u","v","uvs","_vertices","bl","tr","textureRectRotated","temp","vertex","z","_vertexZ","color","_displayedColor","spColor","r","g","_displayedOpacity","_opacityModifyRGB","len","colors"],"mappings":"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","file":"CCProgressTimerWebGLRenderCmd.js","sourceRoot":"../../../../../../../assets/frameworks/cocos2d-html5/cocos2d/progress-timer","sourcesContent":["/****************************************************************************\n Copyright (c) 2013-2014 Chukong Technologies Inc.\n\n http://www.cocos2d-x.org\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n ****************************************************************************/\n\n/**\n * cc.ProgressTimer's rendering objects of WebGL\n */\n(function () {\n    var MAX_VERTEX_COUNT = 8;\n\n    cc.ProgressTimer.WebGLRenderCmd = function (renderableObject) {\n        this._rootCtor(renderableObject);\n        this._needDraw = true;\n        this._progressDirty = true;\n\n        this._bl = cc.p();\n        this._tr = cc.p();\n        this._transformUpdating = false;\n\n        this.initCmd();\n    };\n\n    var proto = cc.ProgressTimer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);\n    proto.constructor = cc.ProgressTimer.WebGLRenderCmd;\n\n    proto.transform = function (parentCmd, recursive) {\n        this.originTransform(parentCmd, recursive);\n        var sp = this._node._sprite;\n        sp._renderCmd.transform(this, recursive);\n\n        var lx = sp._offsetPosition.x, rx = lx + sp._rect.width,\n            by = sp._offsetPosition.y, ty = by + sp._rect.height,\n            wt = this._worldTransform;\n        this._bl.x = lx * wt.a + by * wt.c + wt.tx;\n        this._bl.y = lx * wt.b + by * wt.d + wt.ty;\n        this._tr.x = rx * wt.a + ty * wt.c + wt.tx;\n        this._tr.y = rx * wt.b + ty * wt.d + wt.ty;\n\n        this._transformUpdating = true;\n        this._updateProgressData();\n        this._transformUpdating = false;\n    };\n\n    proto.rendering = function (ctx) {\n        var node = this._node;\n        var context = ctx || cc._renderContext;\n        if (this._vertexDataCount === 0 || !node._sprite)\n            return;\n\n        this._glProgramState.apply();\n        this._shaderProgram._updateProjectionUniform();\n\n        var blendFunc = node._sprite._blendFunc;\n        cc.glBlendFunc(blendFunc.src, blendFunc.dst);\n        cc.glBindTexture2D(node._sprite.texture);\n        context.bindBuffer(context.ARRAY_BUFFER, this._vertexWebGLBuffer);\n\n        context.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);\n        context.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR);\n        context.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS);\n\n        if (this._vertexDataDirty) {\n            context.bufferSubData(context.ARRAY_BUFFER, 0, this._float32View);\n            this._vertexDataDirty = false;\n        }\n        var locVertexDataLen = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;\n        context.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, context.FLOAT, false, locVertexDataLen, 0);\n        context.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, context.UNSIGNED_BYTE, true, locVertexDataLen, 12);\n        context.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, context.FLOAT, false, locVertexDataLen, 16);\n\n        if (node._type === cc.ProgressTimer.TYPE_RADIAL)\n            context.drawArrays(context.TRIANGLE_FAN, 0, this._vertexDataCount);\n        else if (node._type === cc.ProgressTimer.TYPE_BAR) {\n            if (!node._reverseDirection)\n                context.drawArrays(context.TRIANGLE_STRIP, 0, this._vertexDataCount);\n            else {\n                context.drawArrays(context.TRIANGLE_STRIP, 0, this._vertexDataCount / 2);\n                context.drawArrays(context.TRIANGLE_STRIP, 4, this._vertexDataCount / 2);\n                // 2 draw calls\n                cc.g_NumberOfDraws++;\n            }\n        }\n        cc.g_NumberOfDraws++;\n    };\n\n    proto._syncStatus = function (parentCmd) {\n        var node = this._node;\n        if (!node._sprite)\n            return;\n        var flags = cc.Node._dirtyFlags, locFlag = this._dirtyFlag;\n        var parentNode = parentCmd ? parentCmd._node : null;\n\n        if (parentNode && parentNode._cascadeColorEnabled && (parentCmd._dirtyFlag & flags.colorDirty))\n            locFlag |= flags.colorDirty;\n        if (parentNode && parentNode._cascadeOpacityEnabled && (parentCmd._dirtyFlag & flags.opacityDirty))\n            locFlag |= flags.opacityDirty;\n        if (parentCmd && (parentCmd._dirtyFlag & flags.transformDirty))\n            locFlag |= flags.transformDirty;\n        this._dirtyFlag = locFlag;\n\n        var spriteCmd = node._sprite._renderCmd;\n        var spriteFlag = spriteCmd._dirtyFlag;\n\n        var colorDirty = (locFlag | spriteFlag) & flags.colorDirty,\n            opacityDirty = (locFlag | spriteFlag) & flags.opacityDirty;\n\n        if (colorDirty) {\n            spriteCmd._syncDisplayColor();\n            spriteCmd._dirtyFlag &= ~flags.colorDirty;\n            this._dirtyFlag &= ~flags.colorDirty;\n        }\n\n        if (opacityDirty) {\n            spriteCmd._syncDisplayOpacity();\n            spriteCmd._dirtyFlag &= ~flags.opacityDirty;\n            this._dirtyFlag &= ~flags.opacityDirty;\n        }\n\n        if (colorDirty || opacityDirty) {\n            this._updateColor();\n        }\n\n        if (locFlag & flags.transformDirty) {\n            //update the transform\n            this.transform(parentCmd);\n        }\n\n        if (locFlag & flags.textureDirty) {\n            this._updateProgressData();\n            this._dirtyFlag &= ~flags.textureDirty;\n        }\n\n        spriteCmd._dirtyFlag = 0;\n    };\n\n    proto.updateStatus = function () {\n        var node = this._node;\n        if (!node._sprite)\n            return;\n        var flags = cc.Node._dirtyFlags, locFlag = this._dirtyFlag;\n        var spriteCmd = node._sprite._renderCmd;\n        var spriteFlag = spriteCmd._dirtyFlag;\n\n        var colorDirty = (locFlag | spriteFlag) & flags.colorDirty,\n            opacityDirty = (locFlag | spriteFlag) & flags.opacityDirty;\n\n        if (colorDirty) {\n            spriteCmd._updateDisplayColor();\n            spriteCmd._dirtyFlag = spriteCmd._dirtyFlag & flags.colorDirty ^ spriteCmd._dirtyFlag;\n            this._dirtyFlag = this._dirtyFlag & flags.colorDirty ^ this._dirtyFlag;\n        }\n\n        if (opacityDirty) {\n            spriteCmd._updateDisplayOpacity();\n            spriteCmd._dirtyFlag = spriteCmd._dirtyFlag & flags.opacityDirty ^ spriteCmd._dirtyFlag;\n            this._dirtyFlag = this._dirtyFlag & flags.opacityDirty ^ this._dirtyFlag;\n        }\n\n        if (colorDirty || opacityDirty) {\n            this._updateColor();\n        }\n\n        if (locFlag & flags.transformDirty) {\n            //update the transform\n            this.transform(this.getParentRenderCmd(), true);\n        }\n\n        if (locFlag & flags.orderDirty) {\n            this._dirtyFlag = this._dirtyFlag & flags.orderDirty ^ this._dirtyFlag;\n        }\n\n        if (locFlag & flags.textureDirty) {\n            this._updateProgressData();\n            this._dirtyFlag = this._dirtyFlag & flags.textureDirty ^ this._dirtyFlag;\n        }\n    };\n\n    proto.releaseData = function () {\n        if (this._vertexData) {\n            //release all previous information\n            var webglBuffer = this._vertexWebGLBuffer;\n            setTimeout(function () {\n                cc._renderContext.deleteBuffer(webglBuffer);\n            }, 0.1);\n            this._vertexWebGLBuffer = null;\n            this._vertexData = null;\n            this._float32View = null;\n            this._vertexArrayBuffer = null;\n            this._vertexDataCount = 0;\n        }\n    };\n\n    proto.initCmd = function () {\n        if (!this._vertexData) {\n            this._vertexWebGLBuffer = cc._renderContext.createBuffer();\n            \n            var vertexDataLen = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;\n            this._vertexArrayBuffer = new ArrayBuffer(MAX_VERTEX_COUNT * vertexDataLen);\n            this._float32View = new Float32Array(this._vertexArrayBuffer);\n            this._vertexData = [];\n            for (var i = 0; i < MAX_VERTEX_COUNT; i++) {\n                this._vertexData[i] = new cc.V3F_C4B_T2F(null, null, null, this._vertexArrayBuffer, i * vertexDataLen);\n            }\n\n            // Init buffer data\n            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexWebGLBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, this._float32View, gl.DYNAMIC_DRAW);\n\n            this._vertexDataCount = 0;\n            this._vertexDataDirty = true;\n\n            //shader program\n            this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLOR);\n        }\n    };\n\n    proto.resetVertexData = function () {\n        this._vertexDataCount = 0;\n    };\n\n    proto._updateProgressData = function () {\n        var node = this._node;\n        var locType = node._type;\n        if (locType === cc.ProgressTimer.TYPE_RADIAL)\n            this._updateRadial();\n        else if (locType === cc.ProgressTimer.TYPE_BAR)\n            this._updateBar();\n        this._vertexDataDirty = true;\n    };\n\n    proto._updateProgress = function () {\n        this.setDirtyFlag(cc.Node._dirtyFlags.textureDirty);\n    };\n\n    /**\n     * <p>\n     *    Update does the work of mapping the texture onto the triangles for the bar                            <br/>\n     *    It now doesn't occur the cost of free/alloc data every update cycle.                                  <br/>\n     *    It also only changes the percentage point but no other points if they have not been modified.         <br/>\n     *                                                                                                          <br/>\n     *    It now deals with flipped texture. If you run into this problem, just use the                         <br/>\n     *    sprite property and enable the methods flipX, flipY.                                                  <br/>\n     * </p>\n     * @private\n     */\n    proto._updateBar = function () {\n        var node = this._node;\n        if (!node._sprite)\n            return;\n\n        var i, alpha = node._percentage / 100.0;\n        var locBarChangeRate = node._barChangeRate;\n        var alphaOffset = cc.pMult(cc.p((1.0 - locBarChangeRate.x) + alpha * locBarChangeRate.x,\n            (1.0 - locBarChangeRate.y) + alpha * locBarChangeRate.y), 0.5);\n        var min = cc.pSub(node._midPoint, alphaOffset), max = cc.pAdd(node._midPoint, alphaOffset);\n\n        if (min.x < 0) {\n            max.x += -min.x;\n            min.x = 0;\n        }\n\n        if (max.x > 1) {\n            min.x -= max.x - 1;\n            max.x = 1;\n        }\n\n        if (min.y < 0) {\n            max.y += -min.y;\n            min.y = 0;\n        }\n\n        if (max.y > 1) {\n            min.y -= max.y - 1;\n            max.y = 1;\n        }\n\n        var locVertexData;\n        if (!this._reverseDirection) {\n            if (!this._vertexDataCount) {\n                this._vertexDataCount = 4;\n            }\n            locVertexData = this._vertexData;\n            //    TOPLEFT\n            this._textureCoordFromAlphaPoint(locVertexData[0].texCoords, min.x, max.y);\n            this._vertexFromAlphaPoint(locVertexData[0].vertices, min.x, max.y);\n\n            //    BOTLEFT\n            this._textureCoordFromAlphaPoint(locVertexData[1].texCoords, min.x, min.y);\n            this._vertexFromAlphaPoint(locVertexData[1].vertices, min.x, min.y);\n\n            //    TOPRIGHT\n            this._textureCoordFromAlphaPoint(locVertexData[2].texCoords, max.x, max.y);\n            this._vertexFromAlphaPoint(locVertexData[2].vertices, max.x, max.y);\n\n            //    BOTRIGHT\n            this._textureCoordFromAlphaPoint(locVertexData[3].texCoords, max.x, min.y);\n            this._vertexFromAlphaPoint(locVertexData[3].vertices, max.x, min.y);\n        } else {\n            locVertexData = this._vertexData;\n            if (!this._vertexDataCount) {\n                this._vertexDataCount = 8;\n                //    TOPLEFT 1\n                this._textureCoordFromAlphaPoint(locVertexData[0].texCoords, 0, 1);\n                this._vertexFromAlphaPoint(locVertexData[0].vertices, 0, 1);\n\n                //    BOTLEFT 1\n                this._textureCoordFromAlphaPoint(locVertexData[1].texCoords, 0, 0);\n                this._vertexFromAlphaPoint(locVertexData[1].vertices, 0, 0);\n\n                //    TOPRIGHT 2\n                this._textureCoordFromAlphaPoint(locVertexData[6].texCoords, 1, 1);\n                this._vertexFromAlphaPoint(locVertexData[6].vertices, 1, 1);\n\n                //    BOTRIGHT 2\n                this._textureCoordFromAlphaPoint(locVertexData[7].texCoords, 1, 0);\n                this._vertexFromAlphaPoint(locVertexData[7].vertices, 1, 0);\n            }\n\n            //    TOPRIGHT 1\n            this._textureCoordFromAlphaPoint(locVertexData[2].texCoords, min.x, max.y);\n            this._vertexFromAlphaPoint(locVertexData[2].vertices, min.x, max.y);\n\n            //    BOTRIGHT 1\n            this._textureCoordFromAlphaPoint(locVertexData[3].texCoords, min.x, min.y);\n            this._vertexFromAlphaPoint(locVertexData[3].vertices, min.x, min.y);\n\n            //    TOPLEFT 2\n            this._textureCoordFromAlphaPoint(locVertexData[4].texCoords, max.x, max.y);\n            this._vertexFromAlphaPoint(locVertexData[4].vertices, max.x, max.y);\n\n            //    BOTLEFT 2\n            this._textureCoordFromAlphaPoint(locVertexData[5].texCoords, max.x, min.y);\n            this._vertexFromAlphaPoint(locVertexData[5].vertices, max.x, min.y);\n        }\n        this._updateColor();\n    };\n\n    /**\n     * <p>\n     *    Update does the work of mapping the texture onto the triangles            <br/>\n     *    It now doesn't occur the cost of free/alloc data every update cycle.      <br/>\n     *    It also only changes the percentage point but no other points if they have not been modified.       <br/>\n     *                                                                              <br/>\n     *    It now deals with flipped texture. If you run into this problem, just use the                       <br/>\n     *    sprite property and enable the methods flipX, flipY.                      <br/>\n     * </p>\n     * @private\n     */\n    proto._updateRadial = function () {\n        var node = this._node;\n        if (!node._sprite)\n            return;\n\n        var i, locMidPoint = node._midPoint;\n        var alpha = node._percentage / 100;\n        var angle = 2 * (cc.PI) * ( node._reverseDirection ? alpha : 1.0 - alpha);\n\n        //    We find the vector to do a hit detection based on the percentage\n        //    We know the first vector is the one @ 12 o'clock (top,mid) so we rotate\n        //    from that by the progress angle around the m_tMidpoint pivot\n        var topMid = cc.p(locMidPoint.x, 1);\n        var percentagePt = cc.pRotateByAngle(topMid, locMidPoint, angle);\n\n        var index = 0;\n        var hit;\n\n        if (alpha === 0) {\n            //    More efficient since we don't always need to check intersection\n            //    If the alpha is zero then the hit point is top mid and the index is 0.\n            hit = topMid;\n            index = 0;\n        } else if (alpha === 1) {\n            //    More efficient since we don't always need to check intersection\n            //    If the alpha is one then the hit point is top mid and the index is 4.\n            hit = topMid;\n            index = 4;\n        } else {\n            //    We run a for loop checking the edges of the texture to find the\n            //    intersection point\n            //    We loop through five points since the top is split in half\n\n            var min_t = cc.FLT_MAX;\n            var locProTextCoordsCount = cc.ProgressTimer.TEXTURE_COORDS_COUNT;\n            for (i = 0; i <= locProTextCoordsCount; ++i) {\n                var pIndex = (i + (locProTextCoordsCount - 1)) % locProTextCoordsCount;\n\n                var edgePtA = this._boundaryTexCoord(i % locProTextCoordsCount);\n                var edgePtB = this._boundaryTexCoord(pIndex);\n\n                //    Remember that the top edge is split in half for the 12 o'clock position\n                //    Let's deal with that here by finding the correct endpoints\n                if (i === 0)\n                    edgePtB = cc.pLerp(edgePtA, edgePtB, 1 - locMidPoint.x);\n                else if (i === 4)\n                    edgePtA = cc.pLerp(edgePtA, edgePtB, 1 - locMidPoint.x);\n\n                // retPoint are returned by ccpLineIntersect\n                var retPoint = cc.p(0, 0);\n                if (cc.pLineIntersect(edgePtA, edgePtB, locMidPoint, percentagePt, retPoint)) {\n                    //    Since our hit test is on rays we have to deal with the top edge\n                    //    being in split in half so we have to test as a segment\n                    if ((i === 0 || i === 4)) {\n                        //    s represents the point between edgePtA--edgePtB\n                        if (!(0 <= retPoint.x && retPoint.x <= 1))\n                            continue;\n                    }\n                    //    As long as our t isn't negative we are at least finding a\n                    //    correct hitpoint from m_tMidpoint to percentagePt.\n                    if (retPoint.y >= 0) {\n                        //    Because the percentage line and all the texture edges are\n                        //    rays we should only account for the shortest intersection\n                        if (retPoint.y < min_t) {\n                            min_t = retPoint.y;\n                            index = i;\n                        }\n                    }\n                }\n            }\n\n            //    Now that we have the minimum magnitude we can use that to find our intersection\n            hit = cc.pAdd(locMidPoint, cc.pMult(cc.pSub(percentagePt, locMidPoint), min_t));\n        }\n\n        //    The size of the vertex data is the index from the hitpoint\n        //    the 3 is for the m_tMidpoint, 12 o'clock point and hitpoint position.\n        var sameIndexCount = true;\n        if (this._vertexDataCount !== index + 3) {\n            sameIndexCount = false;\n            this._vertexDataCount = index + 3;\n        }\n\n        this._updateColor();\n\n        var locVertexData = this._vertexData;\n        if (this._transformUpdating || !sameIndexCount) {\n            //    First we populate the array with the m_tMidpoint, then all\n            //    vertices/texcoords/colors of the 12 'o clock start and edges and the hitpoint\n            this._textureCoordFromAlphaPoint(locVertexData[0].texCoords, locMidPoint.x, locMidPoint.y);\n            this._vertexFromAlphaPoint(locVertexData[0].vertices, locMidPoint.x, locMidPoint.y);\n\n            this._textureCoordFromAlphaPoint(locVertexData[1].texCoords, topMid.x, topMid.y);\n            this._vertexFromAlphaPoint(locVertexData[1].vertices, topMid.x, topMid.y);\n\n            for (i = 0; i < index; i++) {\n                var alphaPoint = this._boundaryTexCoord(i);\n                this._textureCoordFromAlphaPoint(locVertexData[i + 2].texCoords, alphaPoint.x, alphaPoint.y);\n                this._vertexFromAlphaPoint(locVertexData[i + 2].vertices, alphaPoint.x, alphaPoint.y);\n            }\n        }\n\n        //    hitpoint will go last\n        this._textureCoordFromAlphaPoint(locVertexData[this._vertexDataCount - 1].texCoords, hit.x, hit.y);\n        this._vertexFromAlphaPoint(locVertexData[this._vertexDataCount - 1].vertices, hit.x, hit.y);\n    };\n\n    proto._boundaryTexCoord = function (index) {\n        if (index < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {\n            var locProTextCoords = cc.ProgressTimer.TEXTURE_COORDS;\n            if (this._node._reverseDirection)\n                return cc.p((locProTextCoords >> (7 - (index << 1))) & 1, (locProTextCoords >> (7 - ((index << 1) + 1))) & 1);\n            else\n                return cc.p((locProTextCoords >> ((index << 1) + 1)) & 1, (locProTextCoords >> (index << 1)) & 1);\n        }\n        return cc.p(0, 0);\n    };\n\n    proto._textureCoordFromAlphaPoint = function (coords, ax, ay) {\n        var locSprite = this._node._sprite;\n        if (!locSprite) {\n            coords.u = 0;\n            coords.v = 0;\n            return;\n        }\n        var uvs = locSprite._renderCmd._vertices,\n            bl = uvs[1],\n            tr = uvs[2];\n        var min = cc.p(bl.u, bl.v);\n        var max = cc.p(tr.u, tr.v);\n\n        //  Fix bug #1303 so that progress timer handles sprite frame texture rotation\n        if (locSprite.textureRectRotated) {\n            var temp = ax;\n            ax = ay;\n            ay = temp;\n        }\n        coords.u = min.x * (1 - ax) + max.x * ax;\n        coords.v = min.y * (1 - ay) + max.y * ay;\n    };\n\n    proto._vertexFromAlphaPoint = function (vertex, ax, ay) {\n        vertex.x = this._bl.x * (1 - ax) + this._tr.x * ax;\n        vertex.y = this._bl.y * (1 - ay) + this._tr.y * ay;\n        vertex.z = this._node._vertexZ;\n    };\n\n    proto._updateColor = function () {\n        var sp = this._node._sprite;\n        if (!this._vertexDataCount || !sp)\n            return;\n\n        var color = this._displayedColor;\n        var spColor = sp._renderCmd._displayedColor;\n        var r = spColor.r;\n        var g = spColor.g;\n        var b = spColor.b;\n        var a = sp._renderCmd._displayedOpacity / 255;\n        if (sp._opacityModifyRGB) {\n            r *= a;\n            g *= a;\n            b *= a;\n        }\n        color.r = r;\n        color.g = g;\n        color.b = b;\n        color.a = sp._renderCmd._displayedOpacity;\n        var locVertexData = this._vertexData;\n        for (var i = 0, len = this._vertexDataCount; i < len; ++i) {\n            locVertexData[i].colors = color;\n        }\n        this._vertexDataDirty = true;\n    };\n})();\n"]}