{"version":3,"sources":["../../../../../../../../../../assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger/assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger/main.js"],"names":["DebuggerServer","_listeners","_initialized","globalActorFactories","tabActorFactories","LONG_STRING_LENGTH","LONG_STRING_INITIAL_LENGTH","LONG_STRING_READ_LENGTH","chromeWindowType","allowChromeProcess","init","DS_init","initialized","_connections","_nextConnID","destroy","DS_destroy","Object","getOwnPropertyNames","connID","close","gRegisteredModules","id","unregisterModule","create","closeAllListeners","dumpn","_checkInit","DS_checkInit","createRootActor","isInChildProcess","_onConnection","DS_onConnection","aTransport","aForwardingPrefix","aNoRootActor","conn","DebuggerServerConnection","rootActor","actorID","addActor","send","sayHello","ready","_connectionClosed","DS_connectionClosed","aConnection","prefix","emit","setRootActor","DS_setRootActor","aFunction","aPrefix","_prefix","_transport","hooks","_nextID","_actorPool","ActorPool","_extraPools","_actorResponses","Map","_forwardingPrefixes","prototype","transport","parentMessageManager","DSC_send","aPacket","startBulkSend","header","allocID","DSC_allocID","addActorPool","DSC_addActorPool","aActorPool","push","removeActorPool","DSC_removeActorPool","aNoCleanup","index","lastIndexOf","pool","splice","map","p","cleanup","DSC_addActor","aActor","removeActor","DSC_removeActor","unmanage","getActor","DSC_getActor","aActorID","poolFor","get","_getOrCreateActor","actor","from","error","message","DSC_actorPool","has","_unknownError","DSC__unknownError","aError","_queueResponse","type","response","pendingResponse","resolve","responsePromise","then","aResponse","e","errorPacket","set","setForwarding","cancelForwarding","delete","sendActorEvent","eventName","event","onPacket","DSC_onPacket","size","to","separator","substring","forwardTo","ret","requestTypes","keys","currentPacket","bind","undefined","onBulkPacket","packet","actorKey","length","call","done","reject","Error","onClosed","DSC_onClosed","aStatus","events","_dumpPools","DSC_dumpPools","_dumpPool","aPool"],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AACA;AACA;;;;AAIA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;AAQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAGA,IAAIA,iBAAiB;AACnBC,cAAY,EADO;AAEnBC,gBAAc,KAFK;AAGnB;AACAC,wBAAsB,EAJH;AAKnB;AACAC,qBAAmB,EANA;;AAQnBC,sBAAoB,KARD;AASnBC,8BAA4B,IATT;AAUnBC,2BAAyB,KAAK,IAVX;;AAYnB;;;;;AAKAC,oBAAkB,IAjBC;;AAmBnB;;;AAGAC,sBAAoB,KAtBD;;AAwBnB;;;AAGAC,QAAM,SAASC,OAAT,GAAmB;AACvB,QAAI,KAAKC,WAAT,EAAsB;AACpB;AACD;;AAED,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,WAAL,GAAmB,CAAnB;;AAEA,SAAKZ,YAAL,GAAoB,IAApB;AACD,GApCkB;;AAsCnB;AACA;AACA;;AAEA,MAAIU,WAAJ,GAAkB;AAChB,WAAO,KAAKV,YAAZ;AACD,GA5CkB;;AA8CnB;;;;;;;AAOAa,WAAS,SAASC,UAAT,GAAsB;AAC7B,QAAI,CAAC,KAAKd,YAAV,EAAwB;AACtB;AACD;;AAH4B;AAAA;AAAA;;AAAA;AAK7B,2BAAmBe,OAAOC,mBAAP,CAA2B,KAAKL,YAAhC,CAAnB,8HAAkE;AAAA,YAAzDM,MAAyD;;AAChE,aAAKN,YAAL,CAAkBM,MAAlB,EAA0BC,KAA1B;AACD;AAP4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAS7B,4BAAeH,OAAOC,mBAAP,CAA2BG,kBAA3B,CAAf,mIAA+D;AAAA,YAAtDC,EAAsD;;AAC7D,aAAKC,gBAAL,CAAsBD,EAAtB;AACD;AAX4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAY7BD,yBAAqBJ,OAAOO,MAAP,CAAc,IAAd,CAArB;;AAEA,SAAKC,iBAAL;AACA,SAAKtB,oBAAL,GAA4B,EAA5B;AACA,SAAKC,iBAAL,GAAyB,EAAzB;AACA,SAAKF,YAAL,GAAoB,KAApB;;AAEAwB,UAAM,+BAAN;AACD,GAzEkB;;AA2EnB;;;AAGAC,cAAY,SAASC,YAAT,GAAwB;AAClC,QAAI,CAAC,KAAK1B,YAAV,EAAwB;AACtB,YAAM,0CAAN;AACD;;AAED,QAAI,CAAC,KAAK2B,eAAV,EAA2B;AACzB,YAAM,oEAAN;AACD;AACF,GAtFkB;;AAwFnB;;;;;;;;AAQA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;AAUA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;;;;;;AAMA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AAWA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;AAUA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AAOAC,oBAAkB,KA5uBC;;AA8uBnB;;;;;;;;;;AAUA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;;;;;;;;;;;;;;AAeA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAC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","file":"main.js","sourceRoot":"../../../../../../../../../../assets/frameworks/cocos2d-x/cocos/scripting/js-bindings/script/debugger","sourcesContent":["/****************************************************************************\n Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.\n \n http://www.cocos2d-x.org\n \n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n \n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n \n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n ****************************************************************************/\n\n/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */\n/* vim: set ft=javascript ts=2 et sw=2 tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n\"use strict\";\n\n/**\n * Toolkit glue for the remote debugging protocol, loaded into the\n * debugging global.\n */\n// var { Ci, Cc, CC, Cu, Cr } = require(\"chrome\");\n// var Services = require(\"Services\");\n// var { ActorPool, OriginalLocation, RegisteredActorFactory,\n//       ObservedActorFactory } = require(\"devtools/server/actors/common\");\n// var { LocalDebuggerTransport, ChildDebuggerTransport, WorkerDebuggerTransport } =\n//   require(\"devtools/toolkit/transport/transport\");\n// var DevToolsUtils = require(\"devtools/toolkit/DevToolsUtils\");\n// var { dumpn, dumpv, dbg_assert } = DevToolsUtils;\n// var EventEmitter = require(\"devtools/toolkit/event-emitter\");\n// var Debugger = require(\"Debugger\");\n// var Promise = require(\"promise\");\n\n// DevToolsUtils.defineLazyGetter(this, \"DebuggerSocket\", () => {\n//   let { DebuggerSocket } = require(\"devtools/toolkit/security/socket\");\n//   return DebuggerSocket;\n// });\n// DevToolsUtils.defineLazyGetter(this, \"Authentication\", () => {\n//   return require(\"devtools/toolkit/security/auth\");\n// });\n\n// // On B2G, `this` != Global scope, so `Ci` won't be binded on `this`\n// // (i.e. this.Ci is undefined) Then later, when using loadSubScript,\n// // Ci,... won't be defined for sub scripts.\n// this.Ci = Ci;\n// this.Cc = Cc;\n// this.CC = CC;\n// this.Cu = Cu;\n// this.Cr = Cr;\n// this.Services = Services;\n// this.ActorPool = ActorPool;\n// this.DevToolsUtils = DevToolsUtils;\n// this.dumpn = dumpn;\n// this.dumpv = dumpv;\n// this.dbg_assert = dbg_assert;\n\n// Overload `Components` to prevent SDK loader exception on Components\n// object usage\n// Object.defineProperty(this, \"Components\", {\n//   get: function() {\n//     return require(\"chrome\").components;\n//   }\n// });\n\n// if (isWorker) {\n//   dumpn.wantLogging = true;\n//   dumpv.wantVerbose = true;\n// } else {\n//   const LOG_PREF = \"devtools.debugger.log\";\n//   const VERBOSE_PREF = \"devtools.debugger.log.verbose\";\n\n//   dumpn.wantLogging = Services.prefs.getBoolPref(LOG_PREF);\n//   dumpv.wantVerbose =\n//     Services.prefs.getPrefType(VERBOSE_PREF) !== Services.prefs.PREF_INVALID &&\n//     Services.prefs.getBoolPref(VERBOSE_PREF);\n// }\n\n// function loadSubScript(aURL)\n// {\n//   try {\n//     let loader = Cc[\"@mozilla.org/moz/jssubscript-loader;1\"]\n//       .getService(Ci.mozIJSSubScriptLoader);\n//     loader.loadSubScript(aURL, this);\n//   } catch(e) {\n//     let errorStr = \"Error loading: \" + aURL + \":\\n\" +\n//                    (e.fileName ? \"at \" + e.fileName + \" : \" + e.lineNumber + \"\\n\" : \"\") +\n//                    e + \" - \" + e.stack + \"\\n\";\n//     dump(errorStr);\n//     reportError(errorStr);\n//     throw e;\n//   }\n// }\n\n// loader.lazyRequireGetter(this, \"events\", \"sdk/event/core\");\n\n// var {defer, resolve, reject, all} = require(\"devtools/toolkit/deprecated-sync-thenables\");\n// this.defer = defer;\n// this.resolve = resolve;\n// this.reject = reject;\n// this.all = all;\n\n// var gRegisteredModules = Object.create(null);\n\n/**\n * The ModuleAPI object is passed to modules loaded using the\n * DebuggerServer.registerModule() API.  Modules can use this\n * object to register actor factories.\n * Factories registered through the module API will be removed\n * when the module is unregistered or when the server is\n * destroyed.\n */\n// function ModuleAPI() {\n//   let activeTabActors = new Set();\n//   let activeGlobalActors = new Set();\n\n//   return {\n//     // See DebuggerServer.setRootActor for a description.\n//     setRootActor: function(factory) {\n//       DebuggerServer.setRootActor(factory);\n//     },\n\n//     // See DebuggerServer.addGlobalActor for a description.\n//     addGlobalActor: function(factory, name) {\n//       DebuggerServer.addGlobalActor(factory, name);\n//       activeGlobalActors.add(factory);\n//     },\n//     // See DebuggerServer.removeGlobalActor for a description.\n//     removeGlobalActor: function(factory) {\n//       DebuggerServer.removeGlobalActor(factory);\n//       activeGlobalActors.delete(factory);\n//     },\n\n//     // See DebuggerServer.addTabActor for a description.\n//     addTabActor: function(factory, name) {\n//       DebuggerServer.addTabActor(factory, name);\n//       activeTabActors.add(factory);\n//     },\n//     // See DebuggerServer.removeTabActor for a description.\n//     removeTabActor: function(factory) {\n//       DebuggerServer.removeTabActor(factory);\n//       activeTabActors.delete(factory);\n//     },\n\n//     // Destroy the module API object, unregistering any\n//     // factories registered by the module.\n//     destroy: function() {\n//       for (let factory of activeTabActors) {\n//         DebuggerServer.removeTabActor(factory);\n//       }\n//       activeTabActors = null;\n//       for (let factory of activeGlobalActors) {\n//         DebuggerServer.removeGlobalActor(factory);\n//       }\n//       activeGlobalActors = null;\n//     }\n//   };\n// };\n\n/***\n * Public API\n */\nvar DebuggerServer = {\n  _listeners: [],\n  _initialized: false,\n  // Map of global actor names to actor constructors provided by extensions.\n  globalActorFactories: {},\n  // Map of tab actor names to actor constructors provided by extensions.\n  tabActorFactories: {},\n\n  LONG_STRING_LENGTH: 10000,\n  LONG_STRING_INITIAL_LENGTH: 1000,\n  LONG_STRING_READ_LENGTH: 65 * 1024,\n\n  /**\n   * The windowtype of the chrome window to use for actors that use the global\n   * window (i.e the global style editor). Set this to your main window type,\n   * for example \"navigator:browser\".\n   */\n  chromeWindowType: null,\n\n  /**\n   * Allow debugging chrome of (parent or child) processes.\n   */\n  allowChromeProcess: false,\n\n  /**\n   * Initialize the debugger server.\n   */\n  init: function DS_init() {\n    if (this.initialized) {\n      return;\n    }\n\n    this._connections = {};\n    this._nextConnID = 0;\n\n    this._initialized = true;\n  },\n\n  // get protocol() {\n  //   return require(\"devtools/server/protocol\");\n  // },\n\n  get initialized() {\n    return this._initialized;\n  },\n\n  /**\n   * Performs cleanup tasks before shutting down the debugger server. Such tasks\n   * include clearing any actor constructors added at runtime. This method\n   * should be called whenever a debugger server is no longer useful, to avoid\n   * memory leaks. After this method returns, the debugger server must be\n   * initialized again before use.\n   */\n  destroy: function DS_destroy() {\n    if (!this._initialized) {\n      return;\n    }\n\n    for (let connID of Object.getOwnPropertyNames(this._connections)) {\n      this._connections[connID].close();\n    }\n\n    for (let id of Object.getOwnPropertyNames(gRegisteredModules)) {\n      this.unregisterModule(id);\n    }\n    gRegisteredModules = Object.create(null);\n\n    this.closeAllListeners();\n    this.globalActorFactories = {};\n    this.tabActorFactories = {};\n    this._initialized = false;\n\n    dumpn(\"Debugger server is shut down.\");\n  },\n\n  /**\n   * Raises an exception if the server has not been properly initialized.\n   */\n  _checkInit: function DS_checkInit() {\n    if (!this._initialized) {\n      throw \"DebuggerServer has not been initialized.\";\n    }\n\n    if (!this.createRootActor) {\n      throw \"Use DebuggerServer.addActors() to add a root actor implementation.\";\n    }\n  },\n\n  /**\n   * Load a subscript into the debugging global.\n   *\n   * @param aURL string A url that will be loaded as a subscript into the\n   *        debugging global.  The user must load at least one script\n   *        that implements a createRootActor() function to create the\n   *        server's root actor.\n   */\n  // addActors: function DS_addActors(aURL) {\n  //   loadSubScript.call(this, aURL);\n  // },\n\n  /**\n   * Register a CommonJS module with the debugger server.\n   * @param id string\n   *        The ID of a CommonJS module.  This module must export 'register'\n   *        and 'unregister' functions if no `options` argument is given.\n   *        If `options` is set, the actor is going to be registered\n   *        immediately, but loaded only when a client starts sending packets\n   *        to an actor with the same id.\n   *\n   * @param options object (optional)\n   *        This parameter is still optional, but not providing it is\n   *        deprecated and will result in eagerly loading the actor module\n   *        with the memory overhead that entails.\n   *        An object with 3 mandatory attributes:\n   *        - prefix (string):\n   *          The prefix of an actor is used to compute:\n   *          - the `actorID` of each new actor instance (ex: prefix1).\n   *            (See ActorPool.addActor)\n   *          - the actor name in the listTabs request. Sending a listTabs\n   *            request to the root actor returns actor IDs. IDs are in\n   *            dictionaries, with actor names as keys and actor IDs as values.\n   *            The actor name is the prefix to which the \"Actor\" string is\n   *            appended. So for an actor with the `console` prefix, the actor\n   *            name will be `consoleActor`.\n   *        - constructor (string):\n   *          the name of the exported symbol to be used as the actor\n   *          constructor.\n   *        - type (a dictionary of booleans with following attribute names):\n   *          - \"global\"\n   *            registers a global actor instance, if true.\n   *            A global actor has the root actor as its parent.\n   *          - \"tab\"\n   *            registers a tab actor instance, if true.\n   *            A new actor will be created for each tab and each app.\n   */\n  // registerModule: function(id, options) {\n  //   if (id in gRegisteredModules) {\n  //     throw new Error(\"Tried to register a module twice: \" + id + \"\\n\");\n  //   }\n\n  //   if (options) {\n  //     // Lazy loaded actors\n  //     let {prefix, constructor, type} = options;\n  //     if (typeof(prefix) !== \"string\") {\n  //       throw new Error(\"Lazy actor definition for '\" + id + \"' requires a string 'prefix' option.\");\n  //     }\n  //     if (typeof(constructor) !== \"string\") {\n  //       throw new Error(\"Lazy actor definition for '\" + id + \"' requires a string 'constructor' option.\");\n  //     }\n  //     if (!(\"global\" in type) && !(\"tab\" in type)) {\n  //       throw new Error(\"Lazy actor definition for '\" + id + \"' requires a dictionary 'type' option whose attributes can be 'global' or 'tab'.\");\n  //     }\n  //     let name = prefix + \"Actor\";\n  //     let mod = {\n  //       id: id,\n  //       prefix: prefix,\n  //       constructorName: constructor,\n  //       type: type,\n  //       globalActor: type.global,\n  //       tabActor: type.tab\n  //     };\n  //     gRegisteredModules[id] = mod;\n  //     if (mod.tabActor) {\n  //       this.addTabActor(mod, name);\n  //     }\n  //     if (mod.globalActor) {\n  //       this.addGlobalActor(mod, name);\n  //     }\n  //   } else {\n  //     // Deprecated actors being loaded at startup\n  //     let moduleAPI = ModuleAPI();\n  //     let mod = require(id);\n  //     mod.register(moduleAPI);\n  //     gRegisteredModules[id] = {\n  //       module: mod,\n  //       api: moduleAPI\n  //     };\n  //   }\n  // },\n\n  /**\n   * Returns true if a module id has been registered.\n   */\n  // isModuleRegistered: function(id) {\n  //   return (id in gRegisteredModules);\n  // },\n\n  /**\n   * Unregister a previously-loaded CommonJS module from the debugger server.\n   */\n  // unregisterModule: function(id) {\n  //   let mod = gRegisteredModules[id];\n  //   if (!mod) {\n  //     throw new Error(\"Tried to unregister a module that was not previously registered.\");\n  //   }\n\n  //   // Lazy actors\n  //   if (mod.tabActor) {\n  //     this.removeTabActor(mod);\n  //   }\n  //   if (mod.globalActor) {\n  //     this.removeGlobalActor(mod);\n  //   }\n\n  //   if (mod.module) {\n  //     // Deprecated non-lazy module API\n  //     mod.module.unregister(mod.api);\n  //     mod.api.destroy();\n  //   }\n\n  //   delete gRegisteredModules[id];\n  // },\n\n  /**\n   * Install Firefox-specific actors.\n   *\n   * /!\\ Be careful when adding a new actor, especially global actors.\n   * Any new global actor will be exposed and returned by the root actor.\n   *\n   * That's the reason why tab actors aren't loaded on demand via\n   * restrictPrivileges=true, to prevent exposing them on b2g parent process's\n   * root actor.\n   */\n  // addBrowserActors: function(aWindowType = \"navigator:browser\", restrictPrivileges = false) {\n  //   this.chromeWindowType = aWindowType;\n  //   this.registerModule(\"devtools/server/actors/webbrowser\");\n\n  //   if (!restrictPrivileges) {\n  //     this.addTabActors();\n  //     this.registerModule(\"devtools/server/actors/preference\", {\n  //       prefix: \"preference\",\n  //       constructor: \"PreferenceActor\",\n  //       type: { global: true }\n  //     });\n  //     this.registerModule(\"devtools/server/actors/actor-registry\", {\n  //       prefix: \"actorRegistry\",\n  //       constructor: \"ActorRegistryActor\",\n  //       type: { global: true }\n  //     });\n  //   }\n  //   let win = Services.wm.getMostRecentWindow(DebuggerServer.chromeWindowType);\n  //   if (win && win.navigator.mozSettings) {\n  //     this.registerModule(\"devtools/server/actors/settings\", {\n  //       prefix: \"settings\",\n  //       constructor: \"SettingsActor\",\n  //       type: { global: true }\n  //     });\n  //   }\n  //   this.registerModule(\"devtools/server/actors/webapps\", {\n  //     prefix: \"webapps\",\n  //     constructor: \"WebappsActor\",\n  //     type: { global: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/device\", {\n  //     prefix: \"device\",\n  //     constructor: \"DeviceActor\",\n  //     type: { global: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/director-registry\", {\n  //     prefix: \"directorRegistry\",\n  //     constructor: \"DirectorRegistryActor\",\n  //     type: { global: true }\n  //   });\n  // },\n\n  /**\n   * Install tab actors in documents loaded in content childs\n   */\n  // addChildActors: function () {\n  //   // In case of apps being loaded in parent process, DebuggerServer is already\n  //   // initialized and browser actors are already loaded,\n  //   // but childtab.js hasn't been loaded yet.\n  //   if (!DebuggerServer.tabActorFactories.hasOwnProperty(\"consoleActor\")) {\n  //     this.addTabActors();\n  //   }\n  //   // But webbrowser.js and childtab.js aren't loaded from shell.js.\n  //   if (!this.isModuleRegistered(\"devtools/server/actors/webbrowser\")) {\n  //     this.registerModule(\"devtools/server/actors/webbrowser\");\n  //   }\n  //   if (!(\"ContentActor\" in this)) {\n  //     this.addActors(\"resource://gre/modules/devtools/server/actors/childtab.js\");\n  //   }\n  // },\n\n  /**\n   * Install tab actors.\n   */\n  // addTabActors: function() {\n  //   this.registerModule(\"devtools/server/actors/webconsole\", {\n  //     prefix: \"console\",\n  //     constructor: \"WebConsoleActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/inspector\", {\n  //     prefix: \"inspector\",\n  //     constructor: \"InspectorActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/call-watcher\", {\n  //     prefix: \"callWatcher\",\n  //     constructor: \"CallWatcherActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/canvas\", {\n  //     prefix: \"canvas\",\n  //     constructor: \"CanvasActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/webgl\", {\n  //     prefix: \"webgl\",\n  //     constructor: \"WebGLActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/webaudio\", {\n  //     prefix: \"webaudio\",\n  //     constructor: \"WebAudioActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/stylesheets\", {\n  //     prefix: \"styleSheets\",\n  //     constructor: \"StyleSheetsActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/styleeditor\", {\n  //     prefix: \"styleEditor\",\n  //     constructor: \"StyleEditorActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/storage\", {\n  //     prefix: \"storage\",\n  //     constructor: \"StorageActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/gcli\", {\n  //     prefix: \"gcli\",\n  //     constructor: \"GcliActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/memory\", {\n  //     prefix: \"memory\",\n  //     constructor: \"MemoryActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/memprof\", {\n  //     prefix: \"memprof\",\n  //     constructor: \"MemprofActor\",\n  //     type: { global: true, tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/framerate\", {\n  //     prefix: \"framerate\",\n  //     constructor: \"FramerateActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/eventlooplag\", {\n  //     prefix: \"eventLoopLag\",\n  //     constructor: \"EventLoopLagActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/layout\", {\n  //     prefix: \"reflow\",\n  //     constructor: \"ReflowActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/csscoverage\", {\n  //     prefix: \"cssUsage\",\n  //     constructor: \"CSSUsageActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/monitor\", {\n  //     prefix: \"monitor\",\n  //     constructor: \"MonitorActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/timeline\", {\n  //     prefix: \"timeline\",\n  //     constructor: \"TimelineActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/director-manager\", {\n  //     prefix: \"directorManager\",\n  //     constructor: \"DirectorManagerActor\",\n  //     type: { global: false, tab: true }\n  //   });\n  //   if (\"nsIProfiler\" in Ci) {\n  //     this.registerModule(\"devtools/server/actors/profiler\", {\n  //       prefix: \"profiler\",\n  //       constructor: \"ProfilerActor\",\n  //       type: { tab: true }\n  //     });\n  //     this.registerModule(\"devtools/server/actors/performance\", {\n  //       prefix: \"performance\",\n  //       constructor: \"PerformanceActor\",\n  //       type: { tab: true }\n  //     });\n  //   }\n  //   this.registerModule(\"devtools/server/actors/animation\", {\n  //     prefix: \"animations\",\n  //     constructor: \"AnimationsActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/promises\", {\n  //     prefix: \"promises\",\n  //     constructor: \"PromisesActor\",\n  //     type: { tab: true }\n  //   });\n  //   this.registerModule(\"devtools/server/actors/performance-entries\", {\n  //     prefix: \"performanceEntries\",\n  //     constructor: \"PerformanceEntriesActor\",\n  //     type: { tab: true }\n  //   });\n  // },\n\n  /**\n   * Passes a set of options to the BrowserAddonActors for the given ID.\n   *\n   * @param aId string\n   *        The ID of the add-on to pass the options to\n   * @param aOptions object\n   *        The options.\n   * @return a promise that will be resolved when complete.\n   */\n  // setAddonOptions: function DS_setAddonOptions(aId, aOptions) {\n  //   if (!this._initialized) {\n  //     return;\n  //   }\n\n  //   let promises = [];\n\n  //   // Pass to all connections\n  //   for (let connID of Object.getOwnPropertyNames(this._connections)) {\n  //     promises.push(this._connections[connID].setAddonOptions(aId, aOptions));\n  //   }\n\n  //   return all(promises);\n  // },\n\n  // get listeningSockets() {\n  //   return this._listeners.length;\n  // },\n\n  /**\n   * Creates a socket listener for remote debugger connections.\n   *\n   * After calling this, set some socket options, such as the port / path to\n   * listen on, and then call |open| on the listener.\n   *\n   * See SocketListener in toolkit/devtools/security/socket.js for available\n   * options.\n   *\n   * @return SocketListener\n   *         A SocketListener instance that is waiting to be configured and\n   *         opened is returned.  This single listener can be closed at any\n   *         later time by calling |close| on the SocketListener.  If remote\n   *         connections are disabled, an error is thrown.\n   */\n  // createListener: function() {\n  //   if (!Services.prefs.getBoolPref(\"devtools.debugger.remote-enabled\")) {\n  //     throw new Error(\"Can't create listener, remote debugging disabled\");\n  //   }\n  //   this._checkInit();\n  //   return DebuggerSocket.createListener();\n  // },\n\n  /**\n   * Add a SocketListener instance to the server's set of active\n   * SocketListeners.  This is called by a SocketListener after it is opened.\n   */\n  // _addListener: function(listener) {\n  //   this._listeners.push(listener);\n  // },\n\n  /**\n   * Remove a SocketListener instance from the server's set of active\n   * SocketListeners.  This is called by a SocketListener after it is closed.\n   */\n  // _removeListener: function(listener) {\n  //   this._listeners = this._listeners.filter(l => l !== listener);\n  // },\n\n  /**\n   * Closes and forgets all previously opened listeners.\n   *\n   * @return boolean\n   *         Whether any listeners were actually closed.\n   */\n  // closeAllListeners: function() {\n  //   if (!this.listeningSockets) {\n  //     return false;\n  //   }\n\n  //   for (let listener of this._listeners) {\n  //     listener.close();\n  //   }\n\n  //   return true;\n  // },\n\n  /**\n   * Creates a new connection to the local debugger speaking over a fake\n   * transport. This connection results in straightforward calls to the onPacket\n   * handlers of each side.\n   *\n   * @param aPrefix string [optional]\n   *    If given, all actors in this connection will have names starting\n   *    with |aPrefix + '/'|.\n   * @returns a client-side DebuggerTransport for communicating with\n   *    the newly-created connection.\n   */\n  // connectPipe: function DS_connectPipe(aPrefix) {\n  //   this._checkInit();\n\n  //   let serverTransport = new LocalDebuggerTransport;\n  //   let clientTransport = new LocalDebuggerTransport(serverTransport);\n  //   serverTransport.other = clientTransport;\n  //   let connection = this._onConnection(serverTransport, aPrefix);\n\n  //   // I'm putting this here because I trust you.\n  //   //\n  //   // There are times, when using a local connection, when you're going\n  //   // to be tempted to just get direct access to the server.  Resist that\n  //   // temptation!  If you succumb to that temptation, you will make the\n  //   // fine developers that work on Fennec and Firefox OS sad.  They're\n  //   // professionals, they'll try to act like they understand, but deep\n  //   // down you'll know that you hurt them.\n  //   //\n  //   // This reference allows you to give in to that temptation.  There are\n  //   // times this makes sense: tests, for example, and while porting a\n  //   // previously local-only codebase to the remote protocol.\n  //   //\n  //   // But every time you use this, you will feel the shame of having\n  //   // used a property that starts with a '_'.\n  //   clientTransport._serverConnection = connection;\n\n  //   return clientTransport;\n  // },\n\n  /**\n   * In a content child process, create a new connection that exchanges\n   * nsIMessageSender messages with our parent process.\n   *\n   * @param aPrefix\n   *    The prefix we should use in our nsIMessageSender message names and\n   *    actor names. This connection will use messages named\n   *    \"debug:<prefix>:packet\", and all its actors will have names\n   *    beginning with \"<prefix>/\".\n   */\n  // connectToParent: function(aPrefix, aScopeOrManager) {\n  //   this._checkInit();\n\n  //   let transport = isWorker ?\n  //                   new WorkerDebuggerTransport(aScopeOrManager, aPrefix) :\n  //                   new ChildDebuggerTransport(aScopeOrManager, aPrefix);\n\n  //   return this._onConnection(transport, aPrefix, true);\n  // },\n\n  // connectToContent: function (aConnection, aMm) {\n  //   let deferred = defer();\n\n  //   let prefix = aConnection.allocID(\"content-process\");\n  //   let actor, childTransport;\n\n  //   aMm.addMessageListener(\"debug:content-process-actor\", function listener(msg) {\n  //     // Arbitrarily choose the first content process to reply\n  //     // XXX: This code needs to be updated if we use more than one content process\n  //     aMm.removeMessageListener(\"debug:content-process-actor\", listener);\n\n  //     // Pipe Debugger message from/to parent/child via the message manager\n  //     childTransport = new ChildDebuggerTransport(aMm, prefix);\n  //     childTransport.hooks = {\n  //       onPacket: aConnection.send.bind(aConnection),\n  //       onClosed: function () {}\n  //     };\n  //     childTransport.ready();\n\n  //     aConnection.setForwarding(prefix, childTransport);\n\n  //     dumpn(\"establishing forwarding for process with prefix \" + prefix);\n\n  //     actor = msg.json.actor;\n\n  //     deferred.resolve(actor);\n  //   });\n\n  //   aMm.sendAsyncMessage(\"DevTools:InitDebuggerServer\", {\n  //     prefix: prefix\n  //   });\n\n  //   function onClose() {\n  //     Services.obs.removeObserver(onMessageManagerClose, \"message-manager-close\");\n  //     events.off(aConnection, \"closed\", onClose);\n  //     if (childTransport) {\n  //       // If we have a child transport, the actor has already\n  //       // been created. We need to stop using this message manager.\n  //       childTransport.close();\n  //       childTransport = null;\n  //       aConnection.cancelForwarding(prefix);\n\n  //       // ... and notify the child process to clean the tab actors.\n  //       try {\n  //         aMm.sendAsyncMessage(\"debug:content-process-destroy\");\n  //       } catch(e) {}\n  //     }\n  //   }\n\n  //   let onMessageManagerClose = DevToolsUtils.makeInfallible(function (subject, topic, data) {\n  //     if (subject == aMm) {\n  //       onClose();\n  //       aConnection.send({ from: actor.actor, type: \"tabDetached\" });\n  //     }\n  //   }).bind(this);\n  //   Services.obs.addObserver(onMessageManagerClose,\n  //                            \"message-manager-close\", false);\n\n  //   events.on(aConnection, \"closed\", onClose);\n\n  //   return deferred.promise;\n  // },\n\n  // connectToWorker: function (aConnection, aDbg, aId, aOptions) {\n  //   return new Promise((resolve, reject) => {\n  //     // Step 1: Ensure the worker debugger is initialized.\n  //     if (!aDbg.isInitialized) {\n  //       aDbg.initialize(\"resource://gre/modules/devtools/server/worker.js\");\n\n  //       // Create a listener for rpc requests from the worker debugger. Only do\n  //       // this once, when the worker debugger is first initialized, rather than\n  //       // for each connection.\n  //       let listener = {\n  //         onClose: () => {\n  //           aDbg.removeListener(listener);\n  //         },\n\n  //         onMessage: (message) => {\n  //           let packet = JSON.parse(message);\n  //           if (packet.type !== \"rpc\") {\n  //             return;\n  //           }\n\n  //           Promise.resolve().then(() => {\n  //             let method = {\n  //               \"fetch\": DevToolsUtils.fetch,\n  //             }[packet.method];\n  //             if (!method) {\n  //               throw Error(\"Unknown method: \" + packet.method);\n  //             }\n\n  //             return method.apply(undefined, packet.params);\n  //           }).then((value) => {\n  //             aDbg.postMessage(JSON.stringify({\n  //               type: \"rpc\",\n  //               result: value,\n  //               error: null,\n  //               id: packet.id\n  //             }));\n  //           }, (reason) => {\n  //             aDbg.postMessage(JSON.stringify({\n  //               type: \"rpc\",\n  //               result: null,\n  //               error: reason,\n  //               id: packet.id\n  //             }));\n  //           });\n  //         }\n  //       };\n\n  //       aDbg.addListener(listener);\n  //     }\n\n  //     // Step 2: Send a connect request to the worker debugger.\n  //     aDbg.postMessage(JSON.stringify({\n  //       type: \"connect\",\n  //       id: aId,\n  //       options: aOptions\n  //     }));\n\n  //     // Steps 3-5 are performed on the worker thread (see worker.js).\n\n  //     // Step 6: Wait for a response from the worker debugger.\n  //     let listener = {\n  //       onClose: () => {\n  //         aDbg.removeListener(listener);\n\n  //         reject(\"closed\");\n  //       },\n\n  //       onMessage: (message) => {\n  //         let packet = JSON.parse(message);\n  //         if (packet.type !== \"message\" || packet.id !== aId) {\n  //           return;\n  //         }\n\n  //         message = packet.message;\n  //         if (message.error) {\n  //           reject(error);\n  //         }\n\n  //         if (message.type !== \"paused\") {\n  //           return;\n  //         }\n\n  //         aDbg.removeListener(listener);\n\n  //         // Step 7: Create a transport for the connection to the worker.\n  //         let transport = new WorkerDebuggerTransport(aDbg, aId);\n  //         transport.ready();\n  //         transport.hooks = {\n  //           onClosed: () => {\n  //             if (!aDbg.isClosed) {\n  //               aDbg.postMessage(JSON.stringify({\n  //                 type: \"disconnect\",\n  //                 id: aId\n  //               }));\n  //             }\n\n  //             aConnection.cancelForwarding(aId);\n  //           },\n\n  //           onPacket: (packet) => {\n  //             // Ensure that any packets received from the server on the worker\n  //             // thread are forwarded to the client on the main thread, as if\n  //             // they had been sent by the server on the main thread.\n  //             aConnection.send(packet);\n  //           }\n  //         };\n\n  //         // Ensure that any packets received from the client on the main thread\n  //         // to actors on the worker thread are forwarded to the server on the\n  //         // worker thread.\n  //         aConnection.setForwarding(aId, transport);\n\n  //         resolve({\n  //           threadActor: message.from,\n  //           transport: transport\n  //         });\n  //       }\n  //     };\n  //     aDbg.addListener(listener);\n  //   });\n  // },\n\n  /**\n   * Check if the caller is running in a content child process.\n   * (Eventually set by child.js)\n   *\n   * @return boolean\n   *         true if the caller is running in a content\n   */\n  isInChildProcess: false,\n\n  /**\n   * In a chrome parent process, ask all content child processes\n   * to execute a given module setup helper.\n   *\n   * @param module\n   *        The module to be required\n   * @param setupChild\n   *        The name of the setup helper exported by the above module\n   *        (setup helper signature: function ({mm}) { ... })\n   */\n  // setupInChild: function({ module, setupChild, args }) {\n  //   if (this.isInChildProcess) {\n  //     return;\n  //   }\n\n  //   this._childMessageManagers.forEach(mm => {\n  //     mm.sendAsyncMessage(\"debug:setup-in-child\", {\n  //       module: module,\n  //       setupChild: setupChild,\n  //       args: args,\n  //     });\n  //   });\n  // },\n\n  /**\n   * Live list of all currenctly attached child's message managers.\n   */\n  // _childMessageManagers: new Set(),\n\n  /**\n   * Connect to a child process.\n   *\n   * @param object aConnection\n   *        The debugger server connection to use.\n   * @param nsIDOMElement aFrame\n   *        The browser element that holds the child process.\n   * @param function [aOnDestroy]\n   *        Optional function to invoke when the child process closes\n   *        or the connection shuts down. (Need to forget about the\n   *        related TabActor)\n   * @return object\n   *         A promise object that is resolved once the connection is\n   *         established.\n   */\n  // connectToChild: function(aConnection, aFrame, aOnDestroy) {\n  //   let deferred = defer();\n\n  //   let mm = aFrame.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader\n  //            .messageManager;\n  //   mm.loadFrameScript(\"resource://gre/modules/devtools/server/child.js\", false);\n  //   this._childMessageManagers.add(mm);\n\n  //   let actor, childTransport;\n  //   let prefix = aConnection.allocID(\"child\");\n  //   let netMonitor = null;\n\n  //   // provides hook to actor modules that need to exchange messages\n  //   // between e10s parent and child processes\n  //   let onSetupInParent = function (msg) {\n  //     let { module, setupParent } = msg.json;\n  //     let m, fn;\n\n  //     try {\n  //       m = require(module);\n\n  //       if (!setupParent in m) {\n  //         dumpn(\"ERROR: module '\" + module + \"' does not export '\" + setupParent + \"'\");\n  //         return false;\n  //       }\n\n  //       m[setupParent]({ mm: mm, prefix: prefix });\n\n  //       return true;\n  //     } catch(e) {\n  //       let error_msg = \"exception during actor module setup running in the parent process: \";\n  //       DevToolsUtils.reportException(error_msg + e);\n  //       dumpn(\"ERROR: \" + error_msg + \" \\n\\t module: '\" + module + \"' \\n\\t setupParent: '\" + setupParent + \"'\\n\" +\n  //             DevToolsUtils.safeErrorString(e));\n  //       return false;\n  //     }\n  //   };\n  //   mm.addMessageListener(\"debug:setup-in-parent\", onSetupInParent);\n\n  //   let onActorCreated = DevToolsUtils.makeInfallible(function (msg) {\n  //     if (msg.json.prefix != prefix) {\n  //       return;\n  //     }\n  //     mm.removeMessageListener(\"debug:actor\", onActorCreated);\n\n  //     // Pipe Debugger message from/to parent/child via the message manager\n  //     childTransport = new ChildDebuggerTransport(mm, prefix);\n  //     childTransport.hooks = {\n  //       onPacket: aConnection.send.bind(aConnection),\n  //       onClosed: function () {}\n  //     };\n  //     childTransport.ready();\n\n  //     aConnection.setForwarding(prefix, childTransport);\n\n  //     dumpn(\"establishing forwarding for app with prefix \" + prefix);\n\n  //     actor = msg.json.actor;\n\n  //     let { NetworkMonitorManager } = require(\"devtools/toolkit/webconsole/network-monitor\");\n  //     netMonitor = new NetworkMonitorManager(aFrame, actor.actor);\n\n  //     events.emit(DebuggerServer, \"new-child-process\", { mm: mm });\n\n  //     deferred.resolve(actor);\n  //   }).bind(this);\n  //   mm.addMessageListener(\"debug:actor\", onActorCreated);\n\n  //   let destroy = DevToolsUtils.makeInfallible(function () {\n  //     // provides hook to actor modules that need to exchange messages\n  //     // between e10s parent and child processes\n  //     DebuggerServer.emit(\"disconnected-from-child:\" + prefix, { mm: mm, prefix: prefix });\n\n  //     if (childTransport) {\n  //       // If we have a child transport, the actor has already\n  //       // been created. We need to stop using this message manager.\n  //       childTransport.close();\n  //       childTransport = null;\n  //       aConnection.cancelForwarding(prefix);\n\n  //       // ... and notify the child process to clean the tab actors.\n  //       mm.sendAsyncMessage(\"debug:disconnect\", { prefix: prefix });\n  //     } else {\n  //       // Otherwise, the app has been closed before the actor\n  //       // had a chance to be created, so we are not able to create\n  //       // the actor.\n  //       deferred.resolve(null);\n  //     }\n  //     if (actor) {\n  //       // The ContentActor within the child process doesn't necessary\n  //       // have time to uninitialize itself when the app is closed/killed.\n  //       // So ensure telling the client that the related actor is detached.\n  //       aConnection.send({ from: actor.actor, type: \"tabDetached\" });\n  //       actor = null;\n  //     }\n\n  //     if (netMonitor) {\n  //       netMonitor.destroy();\n  //       netMonitor = null;\n  //     }\n\n  //     if (aOnDestroy) {\n  //       aOnDestroy(mm);\n  //     }\n\n  //     // Cleanup all listeners\n  //     Services.obs.removeObserver(onMessageManagerClose, \"message-manager-close\");\n  //     mm.removeMessageListener(\"debug:setup-in-parent\", onSetupInParent);\n  //     if (!actor) {\n  //       mm.removeMessageListener(\"debug:actor\", onActorCreated);\n  //     }\n  //     events.off(aConnection, \"closed\", destroy);\n\n  //     DebuggerServer._childMessageManagers.delete(mm);\n  //   });\n\n  //   // Listen for app process exit\n  //   let onMessageManagerClose = function (subject, topic, data) {\n  //     if (subject == mm) {\n  //       destroy();\n  //     }\n  //   };\n  //   Services.obs.addObserver(onMessageManagerClose,\n  //                            \"message-manager-close\", false);\n\n  //   // Listen for connection close to cleanup things\n  //   // when user unplug the device or we lose the connection somehow.\n  //   events.on(aConnection, \"closed\", destroy);\n\n  //   mm.sendAsyncMessage(\"debug:connect\", { prefix: prefix });\n\n  //   return deferred.promise;\n  // },\n\n  /**\n   * Create a new debugger connection for the given transport. Called after\n   * connectPipe(), from connectToParent, or from an incoming socket\n   * connection handler.\n   *\n   * If present, |aForwardingPrefix| is a forwarding prefix that a parent\n   * server is using to recognizes messages intended for this server. Ensure\n   * that all our actors have names beginning with |aForwardingPrefix + '/'|.\n   * In particular, the root actor's name will be |aForwardingPrefix + '/root'|.\n   */\n  _onConnection: function DS_onConnection(aTransport, aForwardingPrefix, aNoRootActor) {\n    let connID;\n    if (aForwardingPrefix) {\n      connID = aForwardingPrefix + \"/\";\n    } else {\n      // Multiple servers can be started at the same time, and when that's the\n      // case, they are loaded in separate devtools loaders.\n      // So, use the current loader ID to prefix the connection ID and make it\n      // unique.\n      // connID = \"server\" + loader.id + \".conn\" + this._nextConnID++ + '.';\n      connID = \"server\" + \".conn\" + this._nextConnID++ + '.';\n    }\n\n    let conn = new DebuggerServerConnection(connID, aTransport);\n    this._connections[connID] = conn;\n\n    // Create a root actor for the connection and send the hello packet.\n    if (!aNoRootActor) {\n      conn.rootActor = this.createRootActor(conn);\n      if (aForwardingPrefix)\n        conn.rootActor.actorID = aForwardingPrefix + \"/root\";\n      else\n        conn.rootActor.actorID = \"root\";\n      conn.addActor(conn.rootActor);\n      aTransport.send(conn.rootActor.sayHello());\n    }\n    aTransport.ready();\n\n    // this.emit(\"connectionchange\", \"opened\", conn);\n    return conn;\n  },\n\n  /**\n   * Remove the connection from the debugging server.\n   */\n  _connectionClosed: function DS_connectionClosed(aConnection) {\n    delete this._connections[aConnection.prefix];\n    this.emit(\"connectionchange\", \"closed\", aConnection);\n  },\n\n  // DebuggerServer extension API.\n\n  setRootActor: function DS_setRootActor(aFunction) {\n    this.createRootActor = aFunction;\n  },\n\n  /**\n   * Registers handlers for new tab-scoped request types defined dynamically.\n   * This is used for example by add-ons to augment the functionality of the tab\n   * actor. Note that the name or actorPrefix of the request type is not allowed\n   * to clash with existing protocol packet properties, like 'title', 'url' or\n   * 'actor', since that would break the protocol.\n   *\n   * @param aActor function, object\n   *      In case of function:\n   *        The constructor function for this request type. This expects to be\n   *        called as a constructor (i.e. with 'new'), and passed two\n   *        arguments: the DebuggerServerConnection, and the BrowserTabActor\n   *        with which it will be associated.\n   *        Only used for deprecated eagerly loaded actors.\n   *      In case of object:\n   *        First argument of RegisteredActorFactory constructor.\n   *        See the it's definition for more info.\n   *\n   * @param aName string [optional]\n   *        The name of the new request type. If this is not present, the\n   *        actorPrefix property of the constructor prototype is used.\n   */\n  // addTabActor: function DS_addTabActor(aActor, aName) {\n  //   let name = aName ? aName : aActor.prototype.actorPrefix;\n  //   if ([\"title\", \"url\", \"actor\"].indexOf(name) != -1) {\n  //     throw Error(name + \" is not allowed\");\n  //   }\n  //   if (DebuggerServer.tabActorFactories.hasOwnProperty(name)) {\n  //     throw Error(name + \" already exists\");\n  //   }\n  //   DebuggerServer.tabActorFactories[name] = new RegisteredActorFactory(aActor, name);\n  // },\n\n  /**\n   * Unregisters the handler for the specified tab-scoped request type.\n   * This may be used for example by add-ons when shutting down or upgrading.\n   * When unregistering an existing tab actor remove related tab factory\n   * as well as all existing instances of the actor.\n   *\n   * @param aActor function, object\n   *      In case of function:\n   *        The constructor function for this request type.\n   *      In case of object:\n   *        Same object being given to related addTabActor call.\n   */\n  // removeTabActor: function DS_removeTabActor(aActor) {\n  //   for (let name in DebuggerServer.tabActorFactories) {\n  //     let handler = DebuggerServer.tabActorFactories[name];\n  //     if ((handler.name && handler.name == aActor.name) ||\n  //         (handler.id && handler.id == aActor.id)) {\n  //       delete DebuggerServer.tabActorFactories[name];\n  //       for (let connID of Object.getOwnPropertyNames(this._connections)) {\n  //         this._connections[connID].rootActor.removeActorByName(name);\n  //       }\n  //     }\n  //   }\n  // },\n\n  /**\n   * Registers handlers for new browser-scoped request types defined\n   * dynamically. This is used for example by add-ons to augment the\n   * functionality of the root actor. Note that the name or actorPrefix of the\n   * request type is not allowed to clash with existing protocol packet\n   * properties, like 'from', 'tabs' or 'selected', since that would break the\n   * protocol.\n   *\n   * @param aActor function, object\n   *      In case of function:\n   *        The constructor function for this request type. This expects to be\n   *        called as a constructor (i.e. with 'new'), and passed two\n   *        arguments: the DebuggerServerConnection, and the BrowserRootActor\n   *        with which it will be associated.\n   *        Only used for deprecated eagerly loaded actors.\n   *      In case of object:\n   *        First argument of RegisteredActorFactory constructor.\n   *        See the it's definition for more info.\n   *\n   * @param aName string [optional]\n   *        The name of the new request type. If this is not present, the\n   *        actorPrefix property of the constructor prototype is used.\n   */\n  // addGlobalActor: function DS_addGlobalActor(aActor, aName) {\n  //   let name = aName ? aName : aActor.prototype.actorPrefix;\n  //   if ([\"from\", \"tabs\", \"selected\"].indexOf(name) != -1) {\n  //     throw Error(name + \" is not allowed\");\n  //   }\n  //   if (DebuggerServer.globalActorFactories.hasOwnProperty(name)) {\n  //     throw Error(name + \" already exists\");\n  //   }\n  //   DebuggerServer.globalActorFactories[name] = new RegisteredActorFactory(aActor, name);\n  // },\n\n  /**\n   * Unregisters the handler for the specified browser-scoped request type.\n   * This may be used for example by add-ons when shutting down or upgrading.\n   * When unregistering an existing global actor remove related global factory\n   * as well as all existing instances of the actor.\n   *\n   * @param aActor function, object\n   *      In case of function:\n   *        The constructor function for this request type.\n   *      In case of object:\n   *        Same object being given to related addGlobalActor call.\n   */\n  // removeGlobalActor: function DS_removeGlobalActor(aActor) {\n  //   for (let name in DebuggerServer.globalActorFactories) {\n  //     let handler = DebuggerServer.globalActorFactories[name];\n  //     if ((handler.name && handler.name == aActor.name) ||\n  //         (handler.id && handler.id == aActor.id)) {\n  //       delete DebuggerServer.globalActorFactories[name];\n  //       for (let connID of Object.getOwnPropertyNames(this._connections)) {\n  //         this._connections[connID].rootActor.removeActorByName(name);\n  //       }\n  //     }\n  //   }\n  // }\n};\n\n// Expose these to save callers the trouble of importing DebuggerSocket\n// DevToolsUtils.defineLazyGetter(DebuggerServer, \"Authenticators\", () => {\n//   return Authentication.Authenticators;\n// });\n// DevToolsUtils.defineLazyGetter(DebuggerServer, \"AuthenticationResult\", () => {\n//   return Authentication.AuthenticationResult;\n// });\n\n// EventEmitter.decorate(DebuggerServer);\n\n// if (this.exports) {\n//   exports.DebuggerServer = DebuggerServer;\n//   exports.ActorPool = ActorPool;\n//   exports.OriginalLocation = OriginalLocation;\n// }\n\n// // Needed on B2G (See header note)\n// this.DebuggerServer = DebuggerServer;\n// this.ActorPool = ActorPool;\n// this.OriginalLocation = OriginalLocation;\n\n// When using DebuggerServer.addActors, some symbols are expected to be in\n// the scope of the added actor even before the corresponding modules are\n// loaded, so let's explicitly bind the expected symbols here.\n// var includes = [\"Components\", \"Ci\", \"Cu\", \"require\", \"Services\", \"DebuggerServer\",\n//                 \"ActorPool\", \"DevToolsUtils\"];\n// includes.forEach(name => {\n//   DebuggerServer[name] = this[name];\n// });\n\n/**\n * Creates a DebuggerServerConnection.\n *\n * Represents a connection to this debugging global from a client.\n * Manages a set of actors and actor pools, allocates actor ids, and\n * handles incoming requests.\n *\n * @param aPrefix string\n *        All actor IDs created by this connection should be prefixed\n *        with aPrefix.\n * @param aTransport transport\n *        Packet transport for the debugging protocol.\n */\nfunction DebuggerServerConnection(aPrefix, aTransport)\n{\n  this._prefix = aPrefix;\n  this._transport = aTransport;\n  this._transport.hooks = this;\n  this._nextID = 1;\n\n  this._actorPool = new ActorPool(this);\n  this._extraPools = [this._actorPool];\n\n  // Responses to a given actor must be returned the client\n  // in the same order as the requests that they're replying to, but\n  // Implementations might finish serving requests in a different\n  // order.  To keep things in order we generate a promise for each\n  // request, chained to the promise for the request before it.\n  // This map stores the latest request promise in the chain, keyed\n  // by an actor ID string.\n  this._actorResponses = new Map;\n\n  /*\n   * We can forward packets to other servers, if the actors on that server\n   * all use a distinct prefix on their names. This is a map from prefixes\n   * to transports: it maps a prefix P to a transport T if T conveys\n   * packets to the server whose actors' names all begin with P + \"/\".\n   */\n  this._forwardingPrefixes = new Map;\n}\n\nDebuggerServerConnection.prototype = {\n  _prefix: null,\n  get prefix() { return this._prefix },\n\n  _transport: null,\n  get transport() { return this._transport },\n\n  /**\n   * Message manager used to communicate with the parent process,\n   * set by child.js. Is only defined for connections instantiated\n   * within a child process.\n   */\n  parentMessageManager: null,\n\n  close: function() {\n    this._transport.close();\n  },\n\n  send: function DSC_send(aPacket) {\n    this.transport.send(aPacket);\n  },\n\n  /**\n   * Used when sending a bulk reply from an actor.\n   * @see DebuggerTransport.prototype.startBulkSend\n   */\n  startBulkSend: function(header) {\n    return this.transport.startBulkSend(header);\n  },\n\n  allocID: function DSC_allocID(aPrefix) {\n    return this.prefix + (aPrefix || '') + this._nextID++;\n  },\n\n  /**\n   * Add a map of actor IDs to the connection.\n   */\n  addActorPool: function DSC_addActorPool(aActorPool) {\n    this._extraPools.push(aActorPool);\n  },\n\n  /**\n   * Remove a previously-added pool of actors to the connection.\n   *\n   * @param ActorPool aActorPool\n   *        The ActorPool instance you want to remove.\n   * @param boolean aNoCleanup [optional]\n   *        True if you don't want to disconnect each actor from the pool, false\n   *        otherwise.\n   */\n  removeActorPool: function DSC_removeActorPool(aActorPool, aNoCleanup) {\n    let index = this._extraPools.lastIndexOf(aActorPool);\n    if (index > -1) {\n      let pool = this._extraPools.splice(index, 1);\n      if (!aNoCleanup) {\n        pool.map(function(p) { p.cleanup(); });\n      }\n    }\n  },\n\n  /**\n   * Add an actor to the default actor pool for this connection.\n   */\n  addActor: function DSC_addActor(aActor) {\n    this._actorPool.addActor(aActor);\n  },\n\n  /**\n   * Remove an actor to the default actor pool for this connection.\n   */\n  removeActor: function DSC_removeActor(aActor) {\n    this._actorPool.removeActor(aActor);\n  },\n\n  /**\n   * Match the api expected by the protocol library.\n   */\n  unmanage: function(aActor) {\n    return this.removeActor(aActor);\n  },\n\n  /**\n   * Look up an actor implementation for an actorID.  Will search\n   * all the actor pools registered with the connection.\n   *\n   * @param aActorID string\n   *        Actor ID to look up.\n   */\n  getActor: function DSC_getActor(aActorID) {\n    let pool = this.poolFor(aActorID);\n    if (pool) {\n      return pool.get(aActorID);\n    }\n\n    if (aActorID === \"root\") {\n      return this.rootActor;\n    }\n\n    return null;\n  },\n\n  _getOrCreateActor: function(actorID) {\n    let actor = this.getActor(actorID);\n    if (!actor) {\n      this.transport.send({ from: actorID ? actorID : \"root\",\n                            error: \"noSuchActor\",\n                            message: \"No such actor for ID: \" + actorID });\n      return;\n    }\n\n    // Dynamically-loaded actors have to be created lazily.\n    // if (actor instanceof ObservedActorFactory) {\n    //   try {\n    //     actor= actor.createActor();\n    //   } catch (e) {\n    //     this.transport.send(this._unknownError(\n    //       \"Error occurred while creating actor '\" + actor.name,\n    //       e));\n    //   }\n    // } else if (typeof(actor) !== \"object\") {\n    //   // ActorPools should now contain only actor instances (i.e. objects)\n    //   // or ObservedActorFactory instances.\n    //   throw new Error(\"Unexpected actor constructor/function in ActorPool \" +\n    //                   \"for actorID=\" + actorID + \".\");\n    // }\n\n    return actor;\n  },\n\n  poolFor: function DSC_actorPool(aActorID) {\n    for (let pool of this._extraPools) {\n      if (pool.has(aActorID)) {\n        return pool;\n      }\n    }\n    return null;\n  },\n\n  _unknownError: function DSC__unknownError(aPrefix, aError) {\n    // let errorString = aPrefix + \": \" + DevToolsUtils.safeErrorString(aError);\n    // reportError(errorString);\n    // dumpn(errorString);\n    return {\n      error: \"unknownError\",\n      // message: errorString\n      message: aPrefix + \": \" + aError\n    };\n  },\n\n  _queueResponse: function(from, type, response) {\n    let pendingResponse = this._actorResponses.get(from) || resolve(null);\n    let responsePromise = pendingResponse.then(() => {\n      return response;\n    }).then(aResponse => {\n      if (!aResponse.from) {\n        aResponse.from = from;\n      }\n      this.transport.send(aResponse);\n    }).then(null, (e) => {\n      let errorPacket = this._unknownError(\n        \"error occurred while processing '\" + type,\n        e);\n      errorPacket.from = from;\n      this.transport.send(errorPacket);\n    });\n\n    this._actorResponses.set(from, responsePromise);\n  },\n\n  /**\n   * Passes a set of options to the BrowserAddonActors for the given ID.\n   *\n   * @param aId string\n   *        The ID of the add-on to pass the options to\n   * @param aOptions object\n   *        The options.\n   * @return a promise that will be resolved when complete.\n   */\n  // setAddonOptions: function DSC_setAddonOptions(aId, aOptions) {\n  //   let addonList = this.rootActor._parameters.addonList;\n  //   if (!addonList) {\n  //     return resolve();\n  //   }\n  //   return addonList.getList().then((addonActors) => {\n  //     for (let actor of addonActors) {\n  //       if (actor.id != aId) {\n  //         continue;\n  //       }\n  //       actor.setOptions(aOptions);\n  //       return;\n  //     }\n  //   });\n  // },\n\n  /* Forwarding packets to other transports based on actor name prefixes. */\n\n  /*\n   * Arrange to forward packets to another server. This is how we\n   * forward debugging connections to child processes.\n   *\n   * If we receive a packet for an actor whose name begins with |aPrefix|\n   * followed by '/', then we will forward that packet to |aTransport|.\n   *\n   * This overrides any prior forwarding for |aPrefix|.\n   *\n   * @param aPrefix string\n   *    The actor name prefix, not including the '/'.\n   * @param aTransport object\n   *    A packet transport to which we should forward packets to actors\n   *    whose names begin with |(aPrefix + '/').|\n   */\n  setForwarding: function(aPrefix, aTransport) {\n    this._forwardingPrefixes.set(aPrefix, aTransport);\n  },\n\n  /*\n   * Stop forwarding messages to actors whose names begin with\n   * |aPrefix+'/'|. Such messages will now elicit 'noSuchActor' errors.\n   */\n  cancelForwarding: function(aPrefix) {\n    this._forwardingPrefixes.delete(aPrefix);\n  },\n\n  sendActorEvent: function (actorID, eventName, event = {}) {\n    event.from = actorID;\n    event.type = eventName;\n    this.send(event);\n  },\n\n  // Transport hooks.\n\n  /**\n   * Called by DebuggerTransport to dispatch incoming packets as appropriate.\n   *\n   * @param aPacket object\n   *        The incoming packet.\n   */\n  onPacket: function DSC_onPacket(aPacket) {\n    // If the actor's name begins with a prefix we've been asked to\n    // forward, do so.\n    //\n    // Note that the presence of a prefix alone doesn't indicate that\n    // forwarding is needed: in DebuggerServerConnection instances in child\n    // processes, every actor has a prefixed name.\n    if (this._forwardingPrefixes.size > 0) {\n      let to = aPacket.to;\n      let separator = to.lastIndexOf('/');\n      while (separator >= 0) {\n        to = to.substring(0, separator);\n        let forwardTo = this._forwardingPrefixes.get(aPacket.to.substring(0, separator));\n        if (forwardTo) {\n          forwardTo.send(aPacket);\n          return;\n        }\n        separator = to.lastIndexOf('/');\n      }\n    }\n\n    let actor = this._getOrCreateActor(aPacket.to);\n    if (!actor) {\n      return;\n    }\n\n    var ret = null;\n\n    // handle \"requestTypes\" RDP request.\n    if (aPacket.type == \"requestTypes\") {\n      ret = { from: actor.actorID, requestTypes: Object.keys(actor.requestTypes) };\n    } else if (actor.requestTypes && actor.requestTypes[aPacket.type]) {\n      // Dispatch the request to the actor.\n      try {\n        this.currentPacket = aPacket;\n        ret = actor.requestTypes[aPacket.type].bind(actor)(aPacket, this);\n      } catch(e) {\n        this.transport.send(this._unknownError(\n          \"error occurred while processing '\" + aPacket.type,\n          e));\n        // log(e.stack);\n      } finally {\n        this.currentPacket = undefined;\n      }\n    } else {\n      ret = { error: \"unrecognizedPacketType\",\n              message: (\"Actor \" + actor.actorID +\n                        \" does not recognize the packet type \" +\n                        aPacket.type) };\n    }\n\n    // There will not be a return value if a bulk reply is sent.\n    if (ret) {\n      this._queueResponse(aPacket.to, aPacket.type, ret);\n    }\n  },\n\n  /**\n   * Called by the DebuggerTransport to dispatch incoming bulk packets as\n   * appropriate.\n   *\n   * @param packet object\n   *        The incoming packet, which contains:\n   *        * actor:  Name of actor that will receive the packet\n   *        * type:   Name of actor's method that should be called on receipt\n   *        * length: Size of the data to be read\n   *        * stream: This input stream should only be used directly if you can\n   *                  ensure that you will read exactly |length| bytes and will\n   *                  not close the stream when reading is complete\n   *        * done:   If you use the stream directly (instead of |copyTo|\n   *                  below), you must signal completion by resolving /\n   *                  rejecting this deferred.  If it's rejected, the transport\n   *                  will be closed.  If an Error is supplied as a rejection\n   *                  value, it will be logged via |dumpn|.  If you do use\n   *                  |copyTo|, resolving is taken care of for you when copying\n   *                  completes.\n   *        * copyTo: A helper function for getting your data out of the stream\n   *                  that meets the stream handling requirements above, and has\n   *                  the following signature:\n   *          @param  output nsIAsyncOutputStream\n   *                  The stream to copy to.\n   *          @return Promise\n   *                  The promise is resolved when copying completes or rejected\n   *                  if any (unexpected) errors occur.\n   *                  This object also emits \"progress\" events for each chunk\n   *                  that is copied.  See stream-utils.js.\n   */\n  onBulkPacket: function(packet) {\n    let { actor: actorKey, type, length } = packet;\n\n    let actor = this._getOrCreateActor(actorKey);\n    if (!actor) {\n      return;\n    }\n\n    // Dispatch the request to the actor.\n    let ret;\n    if (actor.requestTypes && actor.requestTypes[type]) {\n      try {\n        ret = actor.requestTypes[type].call(actor, packet);\n      } catch(e) {\n        this.transport.send(this._unknownError(\n          \"error occurred while processing bulk packet '\" + type, e));\n        packet.done.reject(e);\n      }\n    } else {\n      let message = \"Actor \" + actorKey +\n                    \" does not recognize the bulk packet type \" + type;\n      ret = { error: \"unrecognizedPacketType\",\n              message: message };\n      packet.done.reject(new Error(message));\n    }\n\n    // If there is a JSON response, queue it for sending back to the client.\n    if (ret) {\n      this._queueResponse(actorKey, type, ret);\n    }\n  },\n\n  /**\n   * Called by DebuggerTransport when the underlying stream is closed.\n   *\n   * @param aStatus nsresult\n   *        The status code that corresponds to the reason for closing\n   *        the stream.\n   */\n  onClosed: function DSC_onClosed(aStatus) {\n    dumpn(\"Cleaning up connection.\");\n    if (!this._actorPool) {\n      // Ignore this call if the connection is already closed.\n      return;\n    }\n    events.emit(this, \"closed\", aStatus);\n\n    this._actorPool = null;\n    this._extraPools.map(function(p) { p.cleanup(); });\n    this._extraPools = null;\n\n    this.rootActor = null;\n    this._transport = null;\n    DebuggerServer._connectionClosed(this);\n  },\n\n  /*\n   * Debugging helper for inspecting the state of the actor pools.\n   */\n  _dumpPools: function DSC_dumpPools() {\n    // dumpn(\"/-------------------- dumping pools:\");\n    // if (this._actorPool) {\n    //   dumpn(\"--------------------- actorPool actors: \" +\n    //         uneval(Object.keys(this._actorPool._actors)));\n    // }\n    // for (let pool of this._extraPools) {\n    //   if (pool !== this._actorPool) {\n    //     dumpn(\"--------------------- extraPool actors: \" +\n    //           uneval(Object.keys(pool._actors)));\n    //   }\n    // }\n  },\n\n  /*\n   * Debugging helper for inspecting the state of an actor pool.\n   */\n  _dumpPool: function DSC_dumpPools(aPool) {\n    // dumpn(\"/-------------------- dumping pool:\");\n    // dumpn(\"--------------------- actorPool actors: \" +\n    //       uneval(Object.keys(aPool._actors)));\n  },\n\n  /**\n   * In a content child process, ask the DebuggerServer in the parent process\n   * to execute a given module setup helper.\n   *\n   * @param module\n   *        The module to be required\n   * @param setupParent\n   *        The name of the setup helper exported by the above module\n   *        (setup helper signature: function ({mm}) { ... })\n   * @return boolean\n   *         true if the setup helper returned successfully\n   */\n  // setupInParent: function({ conn, module, setupParent }) {\n  //   if (!this.parentMessageManager) {\n  //     return false;\n  //   }\n\n  //   let { sendSyncMessage } = this.parentMessageManager;\n\n  //   return sendSyncMessage(\"debug:setup-in-parent\", {\n  //     module: module,\n  //     setupParent: setupParent\n  //   });\n  // },\n};\n"]}